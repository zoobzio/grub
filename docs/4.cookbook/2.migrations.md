---
title: Data Migrations
description: Migrating data between providers and schema versions
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - cookbook
  - migrations
  - patterns
---

# Data Migrations

This recipe covers patterns for migrating data between grub providers and handling schema evolution.

## The Scenario

You need to:
- Move data from one provider to another (e.g., BoltDB → Redis)
- Upgrade schema versions in existing records
- Transform data during migration

## Provider Migration

### Basic Migration

```go
func migrate(ctx context.Context, src, dst grub.Provider) error {
    cursor := ""

    for {
        keys, nextCursor, err := src.List(ctx, cursor, 100)
        if err != nil {
            return fmt.Errorf("listing keys: %w", err)
        }

        for _, key := range keys {
            data, err := src.Get(ctx, key)
            if err != nil {
                return fmt.Errorf("getting %s: %w", key, err)
            }

            if err := dst.Set(ctx, key, data); err != nil {
                return fmt.Errorf("setting %s: %w", key, err)
            }
        }

        if nextCursor == "" {
            return nil
        }
        cursor = nextCursor
    }
}
```

### Concurrent Migration

```go
func migrateConcurrent(ctx context.Context, src, dst grub.Provider, workers int) error {
    keys := make(chan string, workers*2)
    errs := make(chan error, workers)

    // Start workers
    var wg sync.WaitGroup
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for key := range keys {
                data, err := src.Get(ctx, key)
                if err != nil {
                    errs <- fmt.Errorf("get %s: %w", key, err)
                    return
                }
                if err := dst.Set(ctx, key, data); err != nil {
                    errs <- fmt.Errorf("set %s: %w", key, err)
                    return
                }
            }
        }()
    }

    // Enumerate keys
    go func() {
        defer close(keys)
        cursor := ""
        for {
            batch, next, err := src.List(ctx, cursor, 100)
            if err != nil {
                errs <- err
                return
            }
            for _, k := range batch {
                keys <- k
            }
            if next == "" {
                return
            }
            cursor = next
        }
    }()

    // Wait and check errors
    go func() {
        wg.Wait()
        close(errs)
    }()

    for err := range errs {
        if err != nil {
            return err
        }
    }
    return nil
}
```

### Migration With Progress

```go
type MigrationProgress struct {
    Total     int64
    Completed int64
    Failed    int64
    StartedAt time.Time
}

func migrateWithProgress(ctx context.Context, src, dst grub.Provider) (*MigrationProgress, error) {
    progress := &MigrationProgress{StartedAt: time.Now()}

    // Count total
    total, err := src.Count(ctx)
    if err != nil {
        return nil, err
    }
    progress.Total = total

    cursor := ""
    for {
        keys, next, err := src.List(ctx, cursor, 100)
        if err != nil {
            return progress, err
        }

        for _, key := range keys {
            data, err := src.Get(ctx, key)
            if err != nil {
                atomic.AddInt64(&progress.Failed, 1)
                continue
            }

            if err := dst.Set(ctx, key, data); err != nil {
                atomic.AddInt64(&progress.Failed, 1)
                continue
            }

            atomic.AddInt64(&progress.Completed, 1)
        }

        if next == "" {
            return progress, nil
        }
        cursor = next
    }
}
```

## Schema Migration

### Version Field Pattern

```go
type User struct {
    ID      string `json:"id"`
    Name    string `json:"name"`
    Email   string `json:"email"`
    Version int    `json:"_version"`  // Schema version
}

const CurrentUserVersion = 2

func migrateUser(user User) User {
    switch user.Version {
    case 0, 1:
        // V1 → V2: Normalize email to lowercase
        user.Email = strings.ToLower(user.Email)
        user.Version = 2
        fallthrough
    case 2:
        // Current version
    }
    return user
}
```

### Migrate On Read

```go
func (s *UserService) Get(ctx context.Context, id string) (*User, error) {
    user, err := s.store.Get(ctx, id)
    if err != nil {
        return nil, err
    }

    if user.Version < CurrentUserVersion {
        user = migrateUser(user)
        // Persist migrated version
        if err := s.store.Set(ctx, user.ID, user); err != nil {
            log.Printf("Failed to persist migrated user: %v", err)
        }
    }

    return &user, nil
}
```

### Batch Schema Migration

```go
func migrateAllUsers(ctx context.Context, svc *grub.Service[User]) error {
    cursor := ""

    for {
        keys, next, err := svc.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, key := range keys {
            user, err := svc.Get(ctx, key)
            if err != nil {
                continue
            }

            if user.Version < CurrentUserVersion {
                user = migrateUser(user)
                if err := svc.Set(ctx, user.ID, user); err != nil {
                    return err
                }
            }
        }

        if next == "" {
            return nil
        }
        cursor = next
    }
}
```

## Live Migration

Migrate without downtime using dual-write pattern.

### Phase 1: Dual Write

```go
type DualWriteService struct {
    old *grub.Service[User]
    new *grub.Service[User]
}

func (s *DualWriteService) Set(ctx context.Context, user User) error {
    // Write to both
    if err := s.old.Set(ctx, user.ID, user); err != nil {
        return err
    }
    if err := s.new.Set(ctx, user.ID, user); err != nil {
        // Log but don't fail
        log.Printf("New provider write failed: %v", err)
    }
    return nil
}

func (s *DualWriteService) Get(ctx context.Context, id string) (*User, error) {
    // Read from old (source of truth during migration)
    return s.old.Get(ctx, id)
}
```

### Phase 2: Background Copy

```go
func copyExisting(ctx context.Context, old, new *grub.Service[User]) error {
    cursor := ""
    for {
        keys, next, err := old.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, key := range keys {
            // Check if already in new
            if exists, _ := new.Exists(ctx, key); exists {
                continue
            }

            user, err := old.Get(ctx, key)
            if err != nil {
                continue
            }

            new.Set(ctx, key, user)
        }

        if next == "" {
            return nil
        }
        cursor = next
    }
}
```

### Phase 3: Switch Reads

```go
func (s *DualWriteService) Get(ctx context.Context, id string) (*User, error) {
    // Try new first
    user, err := s.new.Get(ctx, id)
    if err == nil {
        return &user, nil
    }

    // Fall back to old
    return s.old.Get(ctx, id)
}
```

### Phase 4: Remove Old

```go
func (s *DualWriteService) Set(ctx context.Context, user User) error {
    // Write only to new
    return s.new.Set(ctx, user.ID, user)
}
```

## Data Transformation

### Transform During Migration

```go
type OldUser struct {
    ID        string `json:"id"`
    FirstName string `json:"first_name"`
    LastName  string `json:"last_name"`
}

type NewUser struct {
    ID   string `json:"id"`
    Name string `json:"name"`  // Combined
}

func migrateUsers(ctx context.Context, src *grub.Service[OldUser], dst *grub.Service[NewUser]) error {
    cursor := ""
    for {
        keys, next, err := src.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, key := range keys {
            old, err := src.Get(ctx, key)
            if err != nil {
                continue
            }

            new := NewUser{
                ID:   old.ID,
                Name: old.FirstName + " " + old.LastName,
            }

            if err := dst.Set(ctx, new.ID, new); err != nil {
                return err
            }
        }

        if next == "" {
            return nil
        }
        cursor = next
    }
}
```

### Key Transformation

```go
func migrateWithKeyTransform(
    ctx context.Context,
    src, dst grub.Provider,
    transformKey func(string) string,
) error {
    cursor := ""
    for {
        keys, next, err := src.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, oldKey := range keys {
            data, err := src.Get(ctx, oldKey)
            if err != nil {
                continue
            }

            newKey := transformKey(oldKey)
            if err := dst.Set(ctx, newKey, data); err != nil {
                return err
            }
        }

        if next == "" {
            return nil
        }
        cursor = next
    }
}

// Usage: prefix keys
migrateWithKeyTransform(ctx, src, dst, func(k string) string {
    return "v2:" + k
})
```

## Verification

### Verify Migration

```go
func verifyMigration(ctx context.Context, src, dst grub.Provider) error {
    srcCount, _ := src.Count(ctx)
    dstCount, _ := dst.Count(ctx)

    if srcCount != dstCount {
        return fmt.Errorf("count mismatch: src=%d dst=%d", srcCount, dstCount)
    }

    cursor := ""
    for {
        keys, next, err := src.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, key := range keys {
            srcData, err := src.Get(ctx, key)
            if err != nil {
                return fmt.Errorf("src get %s: %w", key, err)
            }

            dstData, err := dst.Get(ctx, key)
            if err != nil {
                return fmt.Errorf("dst get %s: %w", key, err)
            }

            if !bytes.Equal(srcData, dstData) {
                return fmt.Errorf("data mismatch for %s", key)
            }
        }

        if next == "" {
            return nil
        }
        cursor = next
    }
}
```

## See Also

- **[Providers Guide](../3.guides/1.providers.md)** - Provider configuration
- **[Best Practices](../3.guides/5.best-practices.md)** - Schema evolution tips
- **[Multi-tenant Pattern](3.multi-tenant.md)** - Per-tenant migrations
