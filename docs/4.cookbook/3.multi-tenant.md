---
title: Multi-tenant Patterns
description: Tenant isolation strategies with grub
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - cookbook
  - multi-tenant
  - patterns
  - isolation
---

# Multi-tenant Patterns

This recipe covers strategies for isolating tenant data in multi-tenant applications using grub.

## The Scenario

You're building a SaaS application where multiple tenants (customers) share infrastructure but need isolated data. Key requirements:
- Data isolation between tenants
- Efficient per-tenant operations
- Scalable as tenants grow

## Isolation Strategies

### 1. Key Prefix Isolation

Simplest approach: prefix all keys with tenant ID.

```
┌─────────────────────────────────────────────┐
│                 Provider                     │
│  tenant-a:users:usr-1   tenant-b:users:usr-1 │
│  tenant-a:orders:ord-1  tenant-b:orders:ord-2│
└─────────────────────────────────────────────┘
```

```go
type TenantService[T any] struct {
    provider grub.Provider
    codec    grub.Codec
}

func (s *TenantService[T]) Get(ctx context.Context, tenantID, key string) (T, error) {
    fullKey := s.tenantKey(tenantID, key)
    data, err := s.provider.Get(ctx, fullKey)
    if err != nil {
        var zero T
        return zero, err
    }
    var result T
    if err := s.codec.Unmarshal(data, &result); err != nil {
        var zero T
        return zero, err
    }
    return result, nil
}

func (s *TenantService[T]) tenantKey(tenantID, key string) string {
    return tenantID + ":" + key
}
```

**Pros:** Simple, no infrastructure changes
**Cons:** Single provider limits, tenant data mixed

### 2. Provider Per Tenant

Each tenant gets their own provider instance.

```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  Tenant A    │  │  Tenant B    │  │  Tenant C    │
│   Provider   │  │   Provider   │  │   Provider   │
│ (Redis DB 1) │  │ (Redis DB 2) │  │ (Redis DB 3) │
└──────────────┘  └──────────────┘  └──────────────┘
```

```go
type TenantProviderFactory struct {
    providers map[string]grub.Provider
    mu        sync.RWMutex
    factory   func(tenantID string) (grub.Provider, error)
}

func (f *TenantProviderFactory) Get(tenantID string) (grub.Provider, error) {
    f.mu.RLock()
    if p, ok := f.providers[tenantID]; ok {
        f.mu.RUnlock()
        return p, nil
    }
    f.mu.RUnlock()

    f.mu.Lock()
    defer f.mu.Unlock()

    // Double-check
    if p, ok := f.providers[tenantID]; ok {
        return p, nil
    }

    // Create new provider
    p, err := f.factory(tenantID)
    if err != nil {
        return nil, err
    }
    f.providers[tenantID] = p
    return p, nil
}
```

**Pros:** Strong isolation, per-tenant scaling
**Cons:** Resource overhead, connection management

### 3. Bucket/Collection Per Tenant

Cloud providers use tenant-specific buckets or collections.

```go
// S3: bucket per tenant
func newS3Provider(tenantID string) grub.Provider {
    bucket := fmt.Sprintf("myapp-%s", tenantID)
    return s3.New(client, bucket, "data/")
}

// MongoDB: collection per tenant
func newMongoProvider(tenantID string) grub.Provider {
    collection := db.Collection(fmt.Sprintf("tenant_%s", tenantID))
    return mongo.New(collection)
}

// Redis: database per tenant (limited to 16)
func newRedisProvider(tenantID string, dbNum int) grub.Provider {
    client := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
        DB:   dbNum,
    })
    return redispkg.New(client, "")
}
```

**Pros:** Backend-level isolation, easy backup/restore per tenant
**Cons:** Limited databases (Redis), bucket management (S3)

## Implementation Patterns

### Context-Based Tenant Resolution

```go
type tenantKey struct{}

func WithTenant(ctx context.Context, tenantID string) context.Context {
    return context.WithValue(ctx, tenantKey{}, tenantID)
}

func TenantFrom(ctx context.Context) (string, bool) {
    id, ok := ctx.Value(tenantKey{}).(string)
    return id, ok
}

// Middleware
func TenantMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        tenantID := r.Header.Get("X-Tenant-ID")
        if tenantID == "" {
            http.Error(w, "missing tenant", http.StatusBadRequest)
            return
        }
        ctx := WithTenant(r.Context(), tenantID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### Tenant-Aware Service

```go
type MultiTenantService[T any] struct {
    factory *TenantProviderFactory
    name    string
}

func (s *MultiTenantService[T]) service(ctx context.Context) (*grub.Service[T], error) {
    tenantID, ok := TenantFrom(ctx)
    if !ok {
        return nil, errors.New("no tenant in context")
    }

    provider, err := s.factory.Get(tenantID)
    if err != nil {
        return nil, err
    }

    return grub.New[T](provider), nil
}

func (s *MultiTenantService[T]) Get(ctx context.Context, key string) (T, error) {
    svc, err := s.service(ctx)
    if err != nil {
        var zero T
        return zero, err
    }
    return svc.Get(ctx, key)
}

func (s *MultiTenantService[T]) Set(ctx context.Context, key string, value T) error {
    svc, err := s.service(ctx)
    if err != nil {
        return err
    }
    return svc.Set(ctx, key, value)
}
```

### Tenant-Scoped Provider Wrapper

```go
type TenantScopedProvider struct {
    inner    grub.Provider
    tenantID string
}

func NewTenantScoped(inner grub.Provider, tenantID string) *TenantScopedProvider {
    return &TenantScopedProvider{inner: inner, tenantID: tenantID}
}

func (p *TenantScopedProvider) key(k string) string {
    return p.tenantID + ":" + k
}

func (p *TenantScopedProvider) Get(ctx context.Context, key string) ([]byte, error) {
    return p.inner.Get(ctx, p.key(key))
}

func (p *TenantScopedProvider) Set(ctx context.Context, key string, data []byte) error {
    return p.inner.Set(ctx, p.key(key), data)
}

func (p *TenantScopedProvider) Exists(ctx context.Context, key string) (bool, error) {
    return p.inner.Exists(ctx, p.key(key))
}

func (p *TenantScopedProvider) Delete(ctx context.Context, key string) error {
    return p.inner.Delete(ctx, p.key(key))
}

func (p *TenantScopedProvider) Count(ctx context.Context) (int64, error) {
    // Note: This counts ALL keys, not just tenant keys
    // For accurate count, need tenant-aware implementation
    return p.inner.Count(ctx)
}

func (p *TenantScopedProvider) List(ctx context.Context, cursor string, limit int) ([]string, string, error) {
    // Note: This lists ALL keys
    // For tenant-only listing, filter or use tenant-specific provider
    return p.inner.List(ctx, cursor, limit)
}
```

## Tenant Lifecycle

### Onboarding

```go
func onboardTenant(ctx context.Context, tenantID string) error {
    // Create tenant-specific resources
    provider, err := createTenantProvider(tenantID)
    if err != nil {
        return err
    }

    // Initialize with default data
    defaults := grub.New[Setting](provider)
    for _, setting := range defaultSettings {
        if err := defaults.Set(ctx, setting.Key, setting); err != nil {
            return err
        }
    }

    return nil
}
```

### Data Export

```go
func exportTenantData(ctx context.Context, tenantID string, w io.Writer) error {
    provider, err := factory.Get(tenantID)
    if err != nil {
        return err
    }

    encoder := json.NewEncoder(w)
    cursor := ""

    for {
        keys, next, err := provider.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, key := range keys {
            data, err := provider.Get(ctx, key)
            if err != nil {
                continue
            }
            encoder.Encode(map[string]any{
                "key":  key,
                "data": base64.StdEncoding.EncodeToString(data),
            })
        }

        if next == "" {
            return nil
        }
        cursor = next
    }
}
```

### Offboarding

```go
func offboardTenant(ctx context.Context, tenantID string) error {
    provider, err := factory.Get(tenantID)
    if err != nil {
        return err
    }

    // Delete all tenant data
    cursor := ""
    for {
        keys, next, err := provider.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, key := range keys {
            provider.Delete(ctx, key)
        }

        if next == "" {
            break
        }
        cursor = next
    }

    // Close and remove provider
    if lc, ok := provider.(grub.Lifecycle); ok {
        lc.Close(ctx)
    }

    factory.Remove(tenantID)
    return nil
}
```

## Health Checks

### Per-Tenant Health

```go
func tenantHealth(ctx context.Context, tenantID string) error {
    provider, err := factory.Get(tenantID)
    if err != nil {
        return err
    }

    if lc, ok := provider.(grub.Lifecycle); ok {
        return lc.Health(ctx)
    }
    return nil
}
```

### Aggregate Health

```go
func allTenantsHealth(ctx context.Context) map[string]error {
    results := make(map[string]error)

    for tenantID, provider := range factory.All() {
        if lc, ok := provider.(grub.Lifecycle); ok {
            results[tenantID] = lc.Health(ctx)
        }
    }

    return results
}
```

## Testing

```go
func TestMultiTenant(t *testing.T) {
    sharedProvider := grubtesting.NewMockProvider()

    tenantA := NewTenantScoped(sharedProvider, "tenant-a")
    tenantB := NewTenantScoped(sharedProvider, "tenant-b")

    ctx := context.Background()

    // Tenant A writes
    tenantA.Set(ctx, "user:1", []byte(`{"name":"Alice"}`))

    // Tenant B can't see it
    _, err := tenantB.Get(ctx, "user:1")
    if !errors.Is(err, grub.ErrNotFound) {
        t.Error("tenant B should not see tenant A's data")
    }

    // Tenant B writes same key
    tenantB.Set(ctx, "user:1", []byte(`{"name":"Bob"}`))

    // Both have their own data
    dataA, _ := tenantA.Get(ctx, "user:1")
    dataB, _ := tenantB.Get(ctx, "user:1")

    if string(dataA) == string(dataB) {
        t.Error("tenant data should be isolated")
    }
}
```

## See Also

- **[Providers Guide](../3.guides/1.providers.md)** - Provider configuration
- **[Caching Pattern](1.caching.md)** - Per-tenant caching
- **[Migrations](2.migrations.md)** - Per-tenant data migrations
