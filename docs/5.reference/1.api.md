---
title: API Reference
description: Complete API documentation for grub
author: zoobzio
published: 2025-01-07
updated: 2025-01-07
tags:
  - API
  - Reference
  - Documentation
---

# API Reference

Complete documentation for grub's public API.

## Package grub

```go
import "github.com/zoobzio/grub"
```

## Errors

Semantic errors returned by all providers.

| Error | Description |
|-------|-------------|
| `ErrNotFound` | Record does not exist |
| `ErrDuplicate` | Record with same key already exists |
| `ErrConflict` | Concurrent modification conflict |
| `ErrConstraint` | Constraint violation (FK, check, etc.) |
| `ErrInvalidKey` | Key is malformed or empty |
| `ErrReadOnly` | Write attempted on read-only connection |
| `ErrTableExists` | Table name already registered |
| `ErrTableNotFound` | Table not registered |
| `ErrTTLNotSupported` | Provider doesn't support TTL |
| `ErrDimensionMismatch` | Vector dimension doesn't match index |
| `ErrInvalidVector` | Vector is malformed (nil, empty, NaN) |
| `ErrIndexNotReady` | Index not loaded or initialized |
| `ErrInvalidQuery` | Filter contains validation errors |
| `ErrOperatorNotSupported` | Provider doesn't support filter operator |

```go
if errors.Is(err, grub.ErrNotFound) {
    // Handle missing record
}
```

---

## Store[T]

Type-safe key-value store wrapper.

### NewStore

```go
func NewStore[T any](provider StoreProvider) *Store[T]
```

Creates a new Store with JSON codec.

```go
store := grub.NewStore[Session](redis.New(client))
```

### NewStoreWithCodec

```go
func NewStoreWithCodec[T any](provider StoreProvider, codec Codec) *Store[T]
```

Creates a new Store with custom codec.

```go
store := grub.NewStoreWithCodec[Config](provider, grub.GobCodec{})
```

### Methods

#### Get

```go
func (s *Store[T]) Get(ctx context.Context, key string) (*T, error)
```

Retrieves value by key. Returns `ErrNotFound` if key doesn't exist.

```go
session, err := store.Get(ctx, "session:abc123")
```

#### Set

```go
func (s *Store[T]) Set(ctx context.Context, key string, value *T, ttl time.Duration) error
```

Stores value with optional TTL. TTL=0 means no expiration.

```go
store.Set(ctx, "session:abc123", &session, 24*time.Hour)
store.Set(ctx, "config:app", &config, 0) // No expiration
```

#### Delete

```go
func (s *Store[T]) Delete(ctx context.Context, key string) error
```

Removes key. Returns `ErrNotFound` if key doesn't exist.

```go
err := store.Delete(ctx, "session:abc123")
```

#### Exists

```go
func (s *Store[T]) Exists(ctx context.Context, key string) (bool, error)
```

Checks if key exists without loading value.

```go
exists, err := store.Exists(ctx, "session:abc123")
```

#### List

```go
func (s *Store[T]) List(ctx context.Context, prefix string, limit int) ([]string, error)
```

Lists keys matching prefix. Limit=0 means no limit.

```go
keys, err := store.List(ctx, "session:", 100)
keys, err := store.List(ctx, "", 0) // All keys
```

#### GetBatch

```go
func (s *Store[T]) GetBatch(ctx context.Context, keys []string) (map[string]*T, error)
```

Retrieves multiple keys. Missing keys are omitted from result (no error).

```go
users, err := store.GetBatch(ctx, []string{"user:1", "user:2"})
```

#### SetBatch

```go
func (s *Store[T]) SetBatch(ctx context.Context, items map[string]*T, ttl time.Duration) error
```

Stores multiple values with same TTL.

```go
items := map[string]*User{"user:1": &alice, "user:2": &bob}
err := store.SetBatch(ctx, items, time.Hour)
```

#### Atomic

```go
func (s *Store[T]) Atomic() *atomic.Store[T]
```

Returns atomic view for field-level access. Lazily initialized, cached. **Panics if T is not atomizable.**

```go
atomicStore := store.Atomic()
atom, err := atomicStore.Get(ctx, "key")
```

---

## Bucket[T]

Type-safe blob storage wrapper.

### NewBucket

```go
func NewBucket[T any](provider BucketProvider) *Bucket[T]
```

Creates a new Bucket with JSON codec.

```go
bucket := grub.NewBucket[Document](s3.New(client, "my-bucket"))
```

### NewBucketWithCodec

```go
func NewBucketWithCodec[T any](provider BucketProvider, codec Codec) *Bucket[T]
```

Creates a new Bucket with custom codec.

### Methods

#### Get

```go
func (b *Bucket[T]) Get(ctx context.Context, key string) (*Object[T], error)
```

Retrieves object with metadata and payload. Returns `ErrNotFound` if missing.

```go
obj, err := bucket.Get(ctx, "docs/report.json")
fmt.Println(obj.Data.Title)
fmt.Println(obj.ContentType)
```

#### Put

```go
func (b *Bucket[T]) Put(ctx context.Context, obj *Object[T]) error
```

Stores object with metadata.

```go
err := bucket.Put(ctx, &grub.Object[Document]{
    Key:         "docs/report.json",
    ContentType: "application/json",
    Metadata:    map[string]string{"author": "alice"},
    Data:        Document{Title: "Report"},
})
```

#### Delete

```go
func (b *Bucket[T]) Delete(ctx context.Context, key string) error
```

Removes object. Returns `ErrNotFound` if missing.

#### Exists

```go
func (b *Bucket[T]) Exists(ctx context.Context, key string) (bool, error)
```

Checks if object exists.

#### List

```go
func (b *Bucket[T]) List(ctx context.Context, prefix string, limit int) ([]ObjectInfo, error)
```

Lists objects matching prefix. Returns metadata only (no payload).

```go
infos, err := bucket.List(ctx, "docs/", 100)
for _, info := range infos {
    fmt.Printf("%s (%d bytes)\n", info.Key, info.Size)
}
```

#### Atomic

```go
func (b *Bucket[T]) Atomic() *atomic.Bucket[T]
```

Returns atomic view. **Panics if T is not atomizable.**

---

## Database[T]

Type-safe SQL database wrapper.

### NewDatabase

```go
func NewDatabase[T any](
    db *sqlx.DB,
    table string,
    keyCol string,
    renderer astql.Renderer,
) (*Database[T], error)
```

Creates a new Database wrapper.

- `db`: Database connection
- `table`: Table name
- `keyCol`: Primary key column name
- `renderer`: SQL dialect renderer (postgres.New(), mariadb.New(), etc.)

Use the `*Tx` method variants (GetTx, SetTx, etc.) for transaction support.

```go
db, err := grub.NewDatabase[User](sqlxDB, "users", "id", sqlite.New())
```

### Methods

#### Get

```go
func (d *Database[T]) Get(ctx context.Context, key string) (*T, error)
```

Retrieves record by primary key. Returns `ErrNotFound` if missing.

```go
user, err := db.Get(ctx, "123")
```

#### Set

```go
func (d *Database[T]) Set(ctx context.Context, key string, value *T) error
```

Upserts record (insert or update on conflict).

```go
err := db.Set(ctx, "123", &User{ID: "123", Name: "Alice"})
```

#### Delete

```go
func (d *Database[T]) Delete(ctx context.Context, key string) error
```

Removes record. Returns `ErrNotFound` if missing.

#### Exists

```go
func (d *Database[T]) Exists(ctx context.Context, key string) (bool, error)
```

Checks if record exists.

#### Query

```go
func (d *Database[T]) Query(ctx context.Context, name string, params map[string]any) ([]*T, error)
```

Executes named query returning multiple records.

```go
users, err := db.Query(ctx, "active", nil)
users, err := db.Query(ctx, "by_role", map[string]any{"role": "admin"})
```

#### Select

```go
func (d *Database[T]) Select(ctx context.Context, name string, params map[string]any) (*T, error)
```

Executes named query returning single record.

```go
user, err := db.Select(ctx, "by_email", map[string]any{"email": "alice@example.com"})
```

#### Update

```go
func (d *Database[T]) Update(ctx context.Context, name string, params map[string]any) (*T, error)
```

Executes named update returning modified record.

#### Aggregate

```go
func (d *Database[T]) Aggregate(ctx context.Context, stmt edamame.AggregateStatement, params map[string]any) (float64, error)
```

Executes an aggregate statement.

```go
count, err := db.Aggregate(ctx, grub.CountAll, nil)
```

### Transaction Methods

All operations have `*Tx` variants that accept a transaction as the second parameter.

#### GetTx

```go
func (d *Database[T]) GetTx(ctx context.Context, tx *sqlx.Tx, key string) (*T, error)
```

#### SetTx

```go
func (d *Database[T]) SetTx(ctx context.Context, tx *sqlx.Tx, key string, value *T) error
```

#### DeleteTx

```go
func (d *Database[T]) DeleteTx(ctx context.Context, tx *sqlx.Tx, key string) error
```

#### ExistsTx

```go
func (d *Database[T]) ExistsTx(ctx context.Context, tx *sqlx.Tx, key string) (bool, error)
```

#### QueryTx

```go
func (d *Database[T]) QueryTx(ctx context.Context, tx *sqlx.Tx, stmt edamame.QueryStatement, params map[string]any) ([]*T, error)
```

#### SelectTx

```go
func (d *Database[T]) SelectTx(ctx context.Context, tx *sqlx.Tx, stmt edamame.SelectStatement, params map[string]any) (*T, error)
```

#### UpdateTx

```go
func (d *Database[T]) UpdateTx(ctx context.Context, tx *sqlx.Tx, stmt edamame.UpdateStatement, params map[string]any) (*T, error)
```

#### AggregateTx

```go
func (d *Database[T]) AggregateTx(ctx context.Context, tx *sqlx.Tx, stmt edamame.AggregateStatement, params map[string]any) (float64, error)
```

#### Usage Example

```go
tx, err := sqlxDB.BeginTxx(ctx, nil)
if err != nil {
    return err
}
defer tx.Rollback()

user, err := db.GetTx(ctx, tx, "123")
if err != nil {
    return err
}

user.Name = "Updated"
err = db.SetTx(ctx, tx, "123", user)
if err != nil {
    return err
}

return tx.Commit()
```

#### Executor

```go
func (d *Database[T]) Executor() *edamame.Executor[T]
```

Returns the underlying edamame Executor for advanced query operations.

#### Atomic

```go
func (d *Database[T]) Atomic() AtomicDatabase
```

Returns atomic view. **Panics if T is not atomizable.**

---

## Index[T]

Type-safe vector storage wrapper.

### NewIndex

```go
func NewIndex[T any](provider VectorProvider) *Index[T]
```

Creates a new Index with JSON codec.

```go
index := grub.NewIndex[Embedding](qdrant.New(client, qdrant.Config{
    Collection: "documents",
}))
```

### NewIndexWithCodec

```go
func NewIndexWithCodec[T any](provider VectorProvider, codec Codec) *Index[T]
```

Creates a new Index with custom codec.

### Methods

#### Upsert

```go
func (i *Index[T]) Upsert(ctx context.Context, id string, vector []float32, metadata *T) error
```

Stores or updates a vector with associated metadata. If the ID exists, the vector and metadata are replaced.

```go
index.Upsert(ctx, "doc:1", embedding, &Embedding{Category: "tech"})
```

#### UpsertBatch

```go
func (i *Index[T]) UpsertBatch(ctx context.Context, vectors []Vector[T]) error
```

Stores or updates multiple vectors.

```go
vectors := []grub.Vector[Embedding]{
    {ID: "doc:1", Vector: vec1, Metadata: Embedding{Category: "tech"}},
    {ID: "doc:2", Vector: vec2, Metadata: Embedding{Category: "science"}},
}
err := index.UpsertBatch(ctx, vectors)
```

#### Get

```go
func (i *Index[T]) Get(ctx context.Context, id string) (*Vector[T], error)
```

Retrieves a vector by ID. Returns `ErrNotFound` if the ID does not exist.

```go
result, err := index.Get(ctx, "doc:1")
```

#### Delete

```go
func (i *Index[T]) Delete(ctx context.Context, id string) error
```

Removes a vector by ID. Returns `ErrNotFound` if the ID does not exist.

#### DeleteBatch

```go
func (i *Index[T]) DeleteBatch(ctx context.Context, ids []string) error
```

Removes multiple vectors by ID. Non-existent IDs are silently ignored.

#### Search

```go
func (i *Index[T]) Search(ctx context.Context, vector []float32, k int, filter *T) ([]*Vector[T], error)
```

Performs similarity search and returns the k nearest neighbors. Filter is optional metadata filtering (nil means no filter).

```go
results, err := index.Search(ctx, queryVector, 10, nil)
results, err := index.Search(ctx, queryVector, 10, &Embedding{Category: "tech"})
```

#### Query

```go
func (i *Index[T]) Query(ctx context.Context, vector []float32, k int, filter *vecna.Filter) ([]*Vector[T], error)
```

Performs similarity search with vecna filter support. Returns `ErrInvalidQuery` if the filter contains validation errors. Returns `ErrOperatorNotSupported` if the provider doesn't support an operator.

```go
filter := vecna.And(
    vecna.Eq("category", "tech"),
    vecna.Gte("score", 0.8),
)
results, err := index.Query(ctx, queryVector, 10, filter)
```

#### Filter

```go
func (i *Index[T]) Filter(ctx context.Context, filter *vecna.Filter, limit int) ([]*Vector[T], error)
```

Returns vectors matching the metadata filter without similarity search. Result ordering is provider-dependent and not guaranteed by the interface. Limit of 0 returns all matching vectors. Returns `ErrFilterNotSupported` if the provider cannot perform metadata-only filtering (e.g., Pinecone).

```go
filter := vecna.Eq("category", "tech")
results, err := index.Filter(ctx, filter, 100)

// Nil filter returns all vectors
all, err := index.Filter(ctx, nil, 0)
```

#### List

```go
func (i *Index[T]) List(ctx context.Context, prefix string, limit int) ([]string, error)
```

Returns vector IDs matching the optional prefix. Limit of 0 means no limit.

#### Exists

```go
func (i *Index[T]) Exists(ctx context.Context, id string) (bool, error)
```

Checks whether a vector ID exists.

#### Atomic

```go
func (i *Index[T]) Atomic() *atomic.Index[T]
```

Returns atomic view for field-level access. Lazily initialized, cached. **Panics if T is not atomizable.**

---

## Types

### Object[T]

Blob object with metadata and typed payload.

```go
type Object[T any] struct {
    Key         string            `json:"key"`
    ContentType string            `json:"content_type"`
    Size        int64             `json:"size"`
    ETag        string            `json:"etag,omitempty"`
    Metadata    map[string]string `json:"metadata,omitempty"`
    Data        T                 `json:"data"`
}
```

### ObjectInfo

Blob metadata without payload (returned by List).

```go
type ObjectInfo struct {
    Key         string
    ContentType string
    Size        int64
    ETag        string
    Metadata    map[string]string
}
```

### Vector[T]

Vector with typed metadata payload.

```go
type Vector[T any] struct {
    ID       string    `json:"id"`
    Vector   []float32 `json:"vector"`
    Score    float32   `json:"score,omitempty"`
    Metadata T         `json:"metadata"`
}
```

### VectorInfo

Vector metadata returned by providers.

```go
type VectorInfo struct {
    ID        string
    Dimension int
    Score     float32
    Metadata  map[string]any
}
```

### VectorRecord

Batch operation format for vectors.

```go
type VectorRecord struct {
    ID       string
    Vector   []float32
    Metadata map[string]any
}
```

### VectorResult

Search result returned by providers.

```go
type VectorResult struct {
    ID       string
    Vector   []float32
    Metadata map[string]any
    Score    float32
}
```

### AtomicVector

Vector with atomized metadata payload.

```go
type AtomicVector struct {
    ID       string
    Vector   []float32
    Score    float32
    Metadata *atom.Atom
}
```

---

## Interfaces

### StoreProvider

Raw key-value storage interface.

```go
type StoreProvider interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    List(ctx context.Context, prefix string, limit int) ([]string, error)
    GetBatch(ctx context.Context, keys []string) (map[string][]byte, error)
    SetBatch(ctx context.Context, items map[string][]byte, ttl time.Duration) error
}
```

### BucketProvider

Raw blob storage interface.

```go
type BucketProvider interface {
    Get(ctx context.Context, key string) ([]byte, *ObjectInfo, error)
    Put(ctx context.Context, key string, data []byte, info *ObjectInfo) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    List(ctx context.Context, prefix string, limit int) ([]ObjectInfo, error)
}
```

### VectorProvider

Raw vector storage interface.

```go
type VectorProvider interface {
    Upsert(ctx context.Context, id string, vector []float32, metadata map[string]any) error
    UpsertBatch(ctx context.Context, vectors []VectorRecord) error
    Get(ctx context.Context, id string) ([]float32, *VectorInfo, error)
    Delete(ctx context.Context, id string) error
    DeleteBatch(ctx context.Context, ids []string) error
    Search(ctx context.Context, vector []float32, k int, filter map[string]any) ([]VectorResult, error)
    Query(ctx context.Context, vector []float32, k int, filter *vecna.Filter) ([]VectorResult, error)
    Filter(ctx context.Context, filter *vecna.Filter, limit int) ([]VectorResult, error)
    List(ctx context.Context, prefix string, limit int) ([]string, error)
    Exists(ctx context.Context, id string) (bool, error)
}
```

### Codec

Serialization interface.

```go
type Codec interface {
    Encode(v any) ([]byte, error)
    Decode(data []byte, v any) error
}
```

### AtomicStore

Type-agnostic key-value access.

```go
type AtomicStore interface {
    Spec() atom.Spec
    Get(ctx context.Context, key string) (*atom.Atom, error)
    Set(ctx context.Context, key string, a *atom.Atom, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
}
```

### AtomicBucket

Type-agnostic blob access.

```go
type AtomicBucket interface {
    Spec() atom.Spec
    Get(ctx context.Context, key string) (*AtomicObject, error)
    Put(ctx context.Context, key string, obj *AtomicObject) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
}
```

### AtomicDatabase

Type-agnostic SQL access.

```go
type AtomicDatabase interface {
    Table() string
    Spec() atom.Spec
    Get(ctx context.Context, key string) (*atom.Atom, error)
    Set(ctx context.Context, key string, a *atom.Atom) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    Query(ctx context.Context, name string, params map[string]any) ([]*atom.Atom, error)
    Select(ctx context.Context, name string, params map[string]any) (*atom.Atom, error)
}
```

### AtomicIndex

Type-agnostic vector access.

```go
type AtomicIndex interface {
    Spec() atom.Spec
    Get(ctx context.Context, id string) (*AtomicVector, error)
    Upsert(ctx context.Context, id string, vector []float32, metadata *atom.Atom) error
    Delete(ctx context.Context, id string) error
    Exists(ctx context.Context, id string) (bool, error)
    Search(ctx context.Context, vector []float32, k int, filter *atom.Atom) ([]AtomicVector, error)
    Query(ctx context.Context, vector []float32, k int, filter *vecna.Filter) ([]AtomicVector, error)
    Filter(ctx context.Context, filter *vecna.Filter, limit int) ([]AtomicVector, error)
}
```

---

## Codecs

### JSONCodec

Default codec using encoding/json.

```go
type JSONCodec struct{}
```

### GobCodec

Binary codec using encoding/gob.

```go
type GobCodec struct{}
```

### Usage

```go
// Default (JSON)
store := grub.NewStore[Config](provider)

// Custom codec
store := grub.NewStoreWithCodec[Config](provider, grub.GobCodec{})
```
