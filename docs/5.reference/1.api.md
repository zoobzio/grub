---
title: API Reference
description: Complete API documentation for grub
author: zoobzio
published: 2025-01-07
updated: 2025-01-07
tags:
  - API
  - Reference
  - Documentation
---

# API Reference

Complete documentation for grub's public API.

## Package grub

```go
import "github.com/zoobzio/grub"
```

## Errors

Semantic errors returned by all providers.

| Error | Description |
|-------|-------------|
| `ErrNotFound` | Record does not exist |
| `ErrDuplicate` | Record with same key already exists |
| `ErrConflict` | Concurrent modification conflict |
| `ErrConstraint` | Constraint violation (FK, check, etc.) |
| `ErrInvalidKey` | Key is malformed or empty |
| `ErrReadOnly` | Write attempted on read-only connection |
| `ErrTableExists` | Table name already registered |
| `ErrTableNotFound` | Table not registered |
| `ErrTTLNotSupported` | Provider doesn't support TTL |

```go
if errors.Is(err, grub.ErrNotFound) {
    // Handle missing record
}
```

---

## Store[T]

Type-safe key-value store wrapper.

### NewStore

```go
func NewStore[T any](provider StoreProvider) *Store[T]
```

Creates a new Store with JSON codec.

```go
store := grub.NewStore[Session](redis.New(client))
```

### NewStoreWithCodec

```go
func NewStoreWithCodec[T any](provider StoreProvider, codec Codec) *Store[T]
```

Creates a new Store with custom codec.

```go
store := grub.NewStoreWithCodec[Config](provider, grub.GobCodec{})
```

### Methods

#### Get

```go
func (s *Store[T]) Get(ctx context.Context, key string) (*T, error)
```

Retrieves value by key. Returns `ErrNotFound` if key doesn't exist.

```go
session, err := store.Get(ctx, "session:abc123")
```

#### Set

```go
func (s *Store[T]) Set(ctx context.Context, key string, value *T, ttl time.Duration) error
```

Stores value with optional TTL. TTL=0 means no expiration.

```go
store.Set(ctx, "session:abc123", &session, 24*time.Hour)
store.Set(ctx, "config:app", &config, 0) // No expiration
```

#### Delete

```go
func (s *Store[T]) Delete(ctx context.Context, key string) error
```

Removes key. Returns `ErrNotFound` if key doesn't exist.

```go
err := store.Delete(ctx, "session:abc123")
```

#### Exists

```go
func (s *Store[T]) Exists(ctx context.Context, key string) (bool, error)
```

Checks if key exists without loading value.

```go
exists, err := store.Exists(ctx, "session:abc123")
```

#### List

```go
func (s *Store[T]) List(ctx context.Context, prefix string, limit int) ([]string, error)
```

Lists keys matching prefix. Limit=0 means no limit.

```go
keys, err := store.List(ctx, "session:", 100)
keys, err := store.List(ctx, "", 0) // All keys
```

#### GetBatch

```go
func (s *Store[T]) GetBatch(ctx context.Context, keys []string) (map[string]*T, error)
```

Retrieves multiple keys. Missing keys are omitted from result (no error).

```go
users, err := store.GetBatch(ctx, []string{"user:1", "user:2"})
```

#### SetBatch

```go
func (s *Store[T]) SetBatch(ctx context.Context, items map[string]*T, ttl time.Duration) error
```

Stores multiple values with same TTL.

```go
items := map[string]*User{"user:1": &alice, "user:2": &bob}
err := store.SetBatch(ctx, items, time.Hour)
```

#### Atomic

```go
func (s *Store[T]) Atomic() *atomic.Store[T]
```

Returns atomic view for field-level access. Lazily initialized, cached. **Panics if T is not atomizable.**

```go
atomicStore := store.Atomic()
atom, err := atomicStore.Get(ctx, "key")
```

---

## Bucket[T]

Type-safe blob storage wrapper.

### NewBucket

```go
func NewBucket[T any](provider BucketProvider) *Bucket[T]
```

Creates a new Bucket with JSON codec.

```go
bucket := grub.NewBucket[Document](s3.New(client, "my-bucket"))
```

### NewBucketWithCodec

```go
func NewBucketWithCodec[T any](provider BucketProvider, codec Codec) *Bucket[T]
```

Creates a new Bucket with custom codec.

### Methods

#### Get

```go
func (b *Bucket[T]) Get(ctx context.Context, key string) (*Object[T], error)
```

Retrieves object with metadata and payload. Returns `ErrNotFound` if missing.

```go
obj, err := bucket.Get(ctx, "docs/report.json")
fmt.Println(obj.Data.Title)
fmt.Println(obj.ContentType)
```

#### Put

```go
func (b *Bucket[T]) Put(ctx context.Context, obj *Object[T]) error
```

Stores object with metadata.

```go
err := bucket.Put(ctx, &grub.Object[Document]{
    Key:         "docs/report.json",
    ContentType: "application/json",
    Metadata:    map[string]string{"author": "alice"},
    Data:        Document{Title: "Report"},
})
```

#### Delete

```go
func (b *Bucket[T]) Delete(ctx context.Context, key string) error
```

Removes object. Returns `ErrNotFound` if missing.

#### Exists

```go
func (b *Bucket[T]) Exists(ctx context.Context, key string) (bool, error)
```

Checks if object exists.

#### List

```go
func (b *Bucket[T]) List(ctx context.Context, prefix string, limit int) ([]ObjectInfo, error)
```

Lists objects matching prefix. Returns metadata only (no payload).

```go
infos, err := bucket.List(ctx, "docs/", 100)
for _, info := range infos {
    fmt.Printf("%s (%d bytes)\n", info.Key, info.Size)
}
```

#### Atomic

```go
func (b *Bucket[T]) Atomic() *atomic.Bucket[T]
```

Returns atomic view. **Panics if T is not atomizable.**

---

## Database[T]

Type-safe SQL database wrapper.

### NewDatabase

```go
func NewDatabase[T any](
    db sqlx.ExtContext,
    table string,
    keyCol string,
    renderer astql.Renderer,
) (*Database[T], error)
```

Creates a new Database wrapper.

- `db`: *sqlx.DB or *sqlx.Tx
- `table`: Table name
- `keyCol`: Primary key column name
- `renderer`: SQL dialect renderer (postgres.New(), mariadb.New(), etc.)

```go
db, err := grub.NewDatabase[User](sqlxDB, "users", "id", sqlite.New())
```

### Methods

#### Get

```go
func (d *Database[T]) Get(ctx context.Context, key string) (*T, error)
```

Retrieves record by primary key. Returns `ErrNotFound` if missing.

```go
user, err := db.Get(ctx, "123")
```

#### Set

```go
func (d *Database[T]) Set(ctx context.Context, key string, value *T) error
```

Upserts record (insert or update on conflict).

```go
err := db.Set(ctx, "123", &User{ID: "123", Name: "Alice"})
```

#### Delete

```go
func (d *Database[T]) Delete(ctx context.Context, key string) error
```

Removes record. Returns `ErrNotFound` if missing.

#### Exists

```go
func (d *Database[T]) Exists(ctx context.Context, key string) (bool, error)
```

Checks if record exists.

#### Query

```go
func (d *Database[T]) Query(ctx context.Context, name string, params map[string]any) ([]*T, error)
```

Executes named query returning multiple records.

```go
users, err := db.Query(ctx, "active", nil)
users, err := db.Query(ctx, "by_role", map[string]any{"role": "admin"})
```

#### Select

```go
func (d *Database[T]) Select(ctx context.Context, name string, params map[string]any) (*T, error)
```

Executes named query returning single record.

```go
user, err := db.Select(ctx, "by_email", map[string]any{"email": "alice@example.com"})
```

#### Update

```go
func (d *Database[T]) Update(ctx context.Context, name string, params map[string]any) (*T, error)
```

Executes named update returning modified record.

#### Aggregate

```go
func (d *Database[T]) Aggregate(ctx context.Context, name string, params map[string]any) (any, error)
```

Executes named aggregate query.

```go
count, err := db.Aggregate(ctx, "count_active", nil)
```

#### Factory

```go
func (d *Database[T]) Factory() *edamame.Factory[T]
```

Returns underlying edamame factory for advanced queries.

#### Atomic

```go
func (d *Database[T]) Atomic() AtomicDatabase
```

Returns atomic view. **Panics if T is not atomizable.**

---

## Types

### Object[T]

Blob object with metadata and typed payload.

```go
type Object[T any] struct {
    Key         string            `json:"key"`
    ContentType string            `json:"content_type"`
    Size        int64             `json:"size"`
    ETag        string            `json:"etag,omitempty"`
    Metadata    map[string]string `json:"metadata,omitempty"`
    Data        T                 `json:"data"`
}
```

### ObjectInfo

Blob metadata without payload (returned by List).

```go
type ObjectInfo struct {
    Key         string
    ContentType string
    Size        int64
    ETag        string
    Metadata    map[string]string
}
```

---

## Interfaces

### StoreProvider

Raw key-value storage interface.

```go
type StoreProvider interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    List(ctx context.Context, prefix string, limit int) ([]string, error)
    GetBatch(ctx context.Context, keys []string) (map[string][]byte, error)
    SetBatch(ctx context.Context, items map[string][]byte, ttl time.Duration) error
}
```

### BucketProvider

Raw blob storage interface.

```go
type BucketProvider interface {
    Get(ctx context.Context, key string) ([]byte, *ObjectInfo, error)
    Put(ctx context.Context, key string, data []byte, info *ObjectInfo) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    List(ctx context.Context, prefix string, limit int) ([]ObjectInfo, error)
}
```

### Codec

Serialization interface.

```go
type Codec interface {
    Encode(v any) ([]byte, error)
    Decode(data []byte, v any) error
}
```

### AtomicStore

Type-agnostic key-value access.

```go
type AtomicStore interface {
    Spec() atom.Spec
    Get(ctx context.Context, key string) (*atom.Atom, error)
    Set(ctx context.Context, key string, a *atom.Atom, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
}
```

### AtomicBucket

Type-agnostic blob access.

```go
type AtomicBucket interface {
    Spec() atom.Spec
    Get(ctx context.Context, key string) (*AtomicObject, error)
    Put(ctx context.Context, key string, obj *AtomicObject) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
}
```

### AtomicDatabase

Type-agnostic SQL access.

```go
type AtomicDatabase interface {
    Table() string
    Spec() atom.Spec
    Get(ctx context.Context, key string) (*atom.Atom, error)
    Set(ctx context.Context, key string, a *atom.Atom) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    Query(ctx context.Context, name string, params map[string]any) ([]*atom.Atom, error)
    Select(ctx context.Context, name string, params map[string]any) (*atom.Atom, error)
}
```

---

## Codecs

### JSONCodec

Default codec using encoding/json.

```go
type JSONCodec struct{}
```

### GobCodec

Binary codec using encoding/gob.

```go
type GobCodec struct{}
```

### Usage

```go
// Default (JSON)
store := grub.NewStore[Config](provider)

// Custom codec
store := grub.NewStoreWithCodec[Config](provider, grub.GobCodec{})
```
