---
title: API Reference
description: Complete interface and type documentation
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - reference
  - api
  - interfaces
---

# API Reference

Complete documentation for grub's interfaces, types, and errors.

## Interfaces

### Provider

```go
type Provider interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, data []byte) error
    Exists(ctx context.Context, key string) (bool, error)
    Count(ctx context.Context) (int64, error)
    List(ctx context.Context, cursor string, limit int) (keys []string, nextCursor string, err error)
    Delete(ctx context.Context, key string) error
}
```

The storage backend interface. All providers implement this.

#### Get

```go
Get(ctx context.Context, key string) ([]byte, error)
```

Retrieves raw bytes for the given key.

**Parameters:**
- `ctx`: Context for cancellation and deadlines
- `key`: The record key

**Returns:**
- `[]byte`: The raw data
- `error`: `ErrNotFound` if key doesn't exist, other errors for failures

**Example:**
```go
data, err := provider.Get(ctx, "user:123")
if errors.Is(err, grub.ErrNotFound) {
    // Handle missing record
}
```

#### Set

```go
Set(ctx context.Context, key string, data []byte) error
```

Stores raw bytes at the given key. Creates or overwrites.

**Parameters:**
- `ctx`: Context for cancellation and deadlines
- `key`: The record key
- `data`: Raw bytes to store

**Returns:**
- `error`: nil on success, error on failure

**Example:**
```go
err := provider.Set(ctx, "user:123", jsonData)
```

#### Exists

```go
Exists(ctx context.Context, key string) (bool, error)
```

Checks whether a key exists.

**Parameters:**
- `ctx`: Context for cancellation and deadlines
- `key`: The record key

**Returns:**
- `bool`: true if exists
- `error`: nil on success, error on failure

**Example:**
```go
exists, err := provider.Exists(ctx, "user:123")
```

#### Count

```go
Count(ctx context.Context) (int64, error)
```

Returns total number of records.

**Parameters:**
- `ctx`: Context for cancellation and deadlines

**Returns:**
- `int64`: Record count
- `error`: nil on success, error on failure

**Note:** May be expensive for large datasets. Consider caching.

**Example:**
```go
count, err := provider.Count(ctx)
```

#### List

```go
List(ctx context.Context, cursor string, limit int) (keys []string, nextCursor string, err error)
```

Returns a paginated list of keys.

**Parameters:**
- `ctx`: Context for cancellation and deadlines
- `cursor`: Empty for first page, or value from previous `nextCursor`
- `limit`: Maximum keys to return

**Returns:**
- `keys`: Keys for this page
- `nextCursor`: Pass to next call, empty when no more pages
- `error`: nil on success, `ErrInvalidKey` for bad cursor

**Example:**
```go
keys, next, err := provider.List(ctx, "", 100)
for next != "" {
    keys, next, err = provider.List(ctx, next, 100)
}
```

#### Delete

```go
Delete(ctx context.Context, key string) error
```

Removes the record at the given key.

**Parameters:**
- `ctx`: Context for cancellation and deadlines
- `key`: The record key

**Returns:**
- `error`: `ErrNotFound` if key doesn't exist, other errors for failures

**Example:**
```go
err := provider.Delete(ctx, "user:123")
```

---

### Lifecycle

```go
type Lifecycle interface {
    Connect(ctx context.Context) error
    Close(ctx context.Context) error
    Health(ctx context.Context) error
}
```

Connection lifecycle management. All providers implement this.

#### Connect

```go
Connect(ctx context.Context) error
```

Establishes connection to the backing store.

**Parameters:**
- `ctx`: Context for cancellation and deadlines

**Returns:**
- `error`: nil on success (or if no-op), error on failure

**Note:** Most providers are pre-configured, so this is typically a no-op.

#### Close

```go
Close(ctx context.Context) error
```

Releases resources and closes connections.

**Parameters:**
- `ctx`: Context for cancellation and deadlines

**Returns:**
- `error`: nil on success, error on failure

**Warning:** Provider is unusable after Close.

**Example:**
```go
defer provider.Close(context.Background())
```

#### Health

```go
Health(ctx context.Context) error
```

Verifies connectivity with a minimal operation.

**Parameters:**
- `ctx`: Context for cancellation and deadlines

**Returns:**
- `error`: nil if healthy, error describing the issue

**Example:**
```go
if err := provider.Health(ctx); err != nil {
    log.Printf("Provider unhealthy: %v", err)
}
```

---

### Codec

```go
type Codec interface {
    Marshal(v any) ([]byte, error)
    Unmarshal(data []byte, v any) error
    ContentType() string
}
```

Serialization interface for record payloads.

#### Marshal

```go
Marshal(v any) ([]byte, error)
```

Serializes a value to bytes.

#### Unmarshal

```go
Unmarshal(data []byte, v any) error
```

Deserializes bytes into a value.

#### ContentType

```go
ContentType() string
```

Returns MIME type (e.g., `"application/json"`).

---

## Service

```go
type Service[T any] struct {
    // unexported fields
}
```

Generic typed wrapper around a Provider.

### New

```go
func New[T any](provider Provider, opts ...Option[T]) *Service[T]
```

Creates a new typed service.

**Parameters:**
- `provider`: The storage backend
- `opts`: Optional configuration (e.g., `WithCodec[T]`)

**Example:**
```go
users := grub.New[User](provider)
orders := grub.New[Order](provider, grub.WithCodec[Order](myCodec))
```

### Service Methods

All Service methods mirror Provider methods but with typed values:

```go
func (s *Service[T]) Get(ctx context.Context, key string) (*T, error)
func (s *Service[T]) Set(ctx context.Context, key string, value T) error
func (s *Service[T]) Exists(ctx context.Context, key string) (bool, error)
func (s *Service[T]) Count(ctx context.Context) (int64, error)
func (s *Service[T]) List(ctx context.Context, cursor string, limit int) ([]string, string, error)
func (s *Service[T]) Delete(ctx context.Context, key string) error
```

---

## Options

### WithCodec

```go
func WithCodec[T any](c Codec) Option[T]
```

Sets a custom codec for serialization.

**Example:**
```go
svc := grub.New[User](provider, grub.WithCodec[User](ProtoCodec{}))
```

---

## Errors

### Sentinel Errors

```go
var (
    ErrNotFound      = errors.New("grub: record not found")
    ErrAlreadyExists = errors.New("grub: record already exists")
    ErrInvalidKey    = errors.New("grub: invalid key")
    ErrEncode        = errors.New("grub: encoding failed")
    ErrDecode        = errors.New("grub: decoding failed")
    ErrUnsupported   = errors.New("grub: operation not supported")
)
```

| Error | When Returned |
|-------|---------------|
| `ErrNotFound` | Get/Delete on nonexistent key |
| `ErrAlreadyExists` | Reserved for future use |
| `ErrInvalidKey` | Invalid cursor in List |
| `ErrEncode` | Codec.Marshal failed |
| `ErrDecode` | Codec.Unmarshal failed |
| `ErrUnsupported` | Operation not supported by provider |

**Usage:**
```go
if errors.Is(err, grub.ErrNotFound) {
    // Handle missing record
}
```

---

## Signals

Capitan signals for observability:

### Get Signals

```go
var (
    GetStarted   = capitan.NewSignal("grub.get.started", "Get operation started")
    GetCompleted = capitan.NewSignal("grub.get.completed", "Get operation completed")
    GetFailed    = capitan.NewSignal("grub.get.failed", "Get operation failed")
)
```

### Set Signals

```go
var (
    SetStarted   = capitan.NewSignal("grub.set.started", "Set operation started")
    SetCompleted = capitan.NewSignal("grub.set.completed", "Set operation completed")
    SetFailed    = capitan.NewSignal("grub.set.failed", "Set operation failed")
)
```

### Delete Signals

```go
var (
    DeleteStarted   = capitan.NewSignal("grub.delete.started", "Delete operation started")
    DeleteCompleted = capitan.NewSignal("grub.delete.completed", "Delete operation completed")
    DeleteFailed    = capitan.NewSignal("grub.delete.failed", "Delete operation failed")
)
```

### List/Count/Exists Signals

Similar pattern for List, Count, and Exists operations.

---

## Field Keys

```go
var (
    FieldKey      = capitan.NewStringKey("key")
    FieldKeys     = capitan.NewKey[[]string]("keys", "grub.Keys")
    FieldCursor   = capitan.NewStringKey("cursor")
    FieldLimit    = capitan.NewIntKey("limit")
    FieldCount    = capitan.NewInt64Key("count")
    FieldExists   = capitan.NewBoolKey("exists")
    FieldDuration = capitan.NewDurationKey("duration")
    FieldError    = capitan.NewErrorKey("error")
)
```

Extract fields from events:

```go
capitan.Hook(grub.GetCompleted, func(ctx context.Context, e *capitan.Event) {
    key := grub.FieldKey.From(e)
    duration := grub.FieldDuration.From(e)
})
```

---

## Testing Utilities

### MockProvider

```go
type MockProvider struct {
    // in-memory storage
}

func NewMockProvider() *MockProvider
func (m *MockProvider) Reset()
```

In-memory provider for testing. Implements both `Provider` and `Lifecycle`.

### EventCapture

```go
type EventCapture struct {
    // captured events
}

func NewEventCapture() *EventCapture
func (c *EventCapture) Handler() capitan.EventCallback
func (c *EventCapture) Events() []CapturedEvent
func (c *EventCapture) EventsBySignal(sig capitan.Signal) []CapturedEvent
func (c *EventCapture) Count() int
func (c *EventCapture) Reset()
```

Captures Capitan events for test verification.

---

## See Also

- **[Concepts](../2.learn/2.concepts.md)** - Understanding interfaces
- **[Provider Reference](2.providers.md)** - Provider-specific details
- **[Testing Guide](../3.guides/4.testing.md)** - Using test utilities
