---
title: Lifecycle Guide
description: Connection management, health checks, and graceful shutdown
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - lifecycle
  - health-checks
  - connection-management
---

# Lifecycle Guide

The Lifecycle interface provides connection management for grub providers. This guide covers patterns for health checks, graceful shutdown, and connection pooling.

## The Lifecycle Interface

```go
type Lifecycle interface {
    Connect(ctx context.Context) error
    Close(ctx context.Context) error
    Health(ctx context.Context) error
}
```

All grub providers implement this interface.

## Health Checks

### Basic Health Check

```go
if err := provider.Health(ctx); err != nil {
    log.Printf("Provider unhealthy: %v", err)
}
```

### HTTP Health Endpoint

```go
func healthHandler(provider grub.Lifecycle) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
        defer cancel()

        if err := provider.Health(ctx); err != nil {
            w.WriteHeader(http.StatusServiceUnavailable)
            fmt.Fprintf(w, "unhealthy: %v", err)
            return
        }

        w.WriteHeader(http.StatusOK)
        w.Write([]byte("healthy"))
    }
}

// Usage
http.HandleFunc("/health", healthHandler(provider))
```

### Kubernetes Probes

```go
// Liveness probe - is the app alive?
http.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
})

// Readiness probe - can the app serve traffic?
http.HandleFunc("/readyz", func(w http.ResponseWriter, r *http.Request) {
    if err := provider.Health(r.Context()); err != nil {
        w.WriteHeader(http.StatusServiceUnavailable)
        return
    }
    w.WriteHeader(http.StatusOK)
})
```

### Multiple Providers

```go
type HealthChecker struct {
    providers map[string]grub.Lifecycle
}

func (h *HealthChecker) Check(ctx context.Context) map[string]error {
    results := make(map[string]error)

    var wg sync.WaitGroup
    var mu sync.Mutex

    for name, provider := range h.providers {
        wg.Add(1)
        go func(name string, p grub.Lifecycle) {
            defer wg.Done()
            err := p.Health(ctx)
            mu.Lock()
            results[name] = err
            mu.Unlock()
        }(name, provider)
    }

    wg.Wait()
    return results
}
```

## Graceful Shutdown

### Basic Pattern

```go
func main() {
    ctx := context.Background()

    provider := redis.New(client, "myapp:")
    defer provider.Close(ctx)

    // Application logic...
}
```

### Signal Handling

```go
func main() {
    ctx, cancel := context.WithCancel(context.Background())

    provider := redis.New(client, "myapp:")

    // Handle shutdown signals
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        <-sigCh
        log.Println("Shutdown signal received")

        // Close provider with timeout
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := provider.Close(shutdownCtx); err != nil {
            log.Printf("Error closing provider: %v", err)
        }

        cancel()
    }()

    // Run application
    if err := run(ctx, provider); err != nil {
        log.Fatal(err)
    }
}
```

### HTTP Server Shutdown

```go
func main() {
    provider := redis.New(client, "myapp:")

    server := &http.Server{Addr: ":8080"}

    // Start server
    go func() {
        if err := server.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()

    // Wait for interrupt
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    // Graceful shutdown
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // Stop accepting new requests
    server.Shutdown(ctx)

    // Close provider after server stops
    provider.Close(ctx)
}
```

## Connection Patterns

### Shared Provider

Multiple services can share a single provider:

```go
provider := redis.New(client, "myapp:")

users := grub.New[User](provider)
sessions := grub.New[Session](provider)
cache := grub.New[CacheEntry](provider)

// Single health check covers all services
provider.Health(ctx)

// Single close cleans up everything
defer provider.Close(ctx)
```

### Provider Per Service

For isolation or different backends:

```go
type App struct {
    userProvider    grub.Lifecycle
    sessionProvider grub.Lifecycle
    users           *grub.Service[User]
    sessions        *grub.Service[Session]
}

func (a *App) Health(ctx context.Context) error {
    if err := a.userProvider.Health(ctx); err != nil {
        return fmt.Errorf("user provider: %w", err)
    }
    if err := a.sessionProvider.Health(ctx); err != nil {
        return fmt.Errorf("session provider: %w", err)
    }
    return nil
}

func (a *App) Close(ctx context.Context) error {
    var errs []error
    if err := a.userProvider.Close(ctx); err != nil {
        errs = append(errs, err)
    }
    if err := a.sessionProvider.Close(ctx); err != nil {
        errs = append(errs, err)
    }
    return errors.Join(errs...)
}
```

### Lazy Initialization

```go
type LazyProvider struct {
    init     func() (grub.Provider, error)
    provider grub.Provider
    once     sync.Once
    err      error
}

func (l *LazyProvider) get() (grub.Provider, error) {
    l.once.Do(func() {
        l.provider, l.err = l.init()
    })
    return l.provider, l.err
}

func (l *LazyProvider) Get(ctx context.Context, key string) ([]byte, error) {
    p, err := l.get()
    if err != nil {
        return nil, err
    }
    return p.Get(ctx, key)
}

// ... implement other methods similarly
```

## Provider-Specific Behavior

### What Each Provider Does

| Provider | Connect | Close | Health |
|----------|---------|-------|--------|
| Redis | No-op | Closes client | PING |
| S3 | No-op | No-op | HeadBucket |
| MongoDB | No-op | Disconnects client | Ping |
| DynamoDB | No-op | No-op | DescribeTable |
| Firestore | No-op | Closes client | List 1 doc |
| GCS | No-op | Closes client | Bucket attrs |
| Azure | No-op | No-op | Container props |
| BoltDB | No-op | Closes DB file | Read txn |
| BadgerDB | No-op | Closes DB | Read txn |

### Connect Behavior

Most providers receive pre-configured clients, so `Connect()` is a no-op. The connection is established when you create the underlying client:

```go
// Connection happens here
client := redis.NewClient(&redis.Options{Addr: "localhost:6379"})

// Not here
provider := grubRedis.New(client, "prefix:")
provider.Connect(ctx)  // No-op
```

### Close Behavior

`Close()` releases resources held by the provider:

- **Stateful providers** (Redis, MongoDB, BoltDB, BadgerDB, Firestore, GCS): Close the underlying client/connection
- **Stateless providers** (S3, DynamoDB, Azure): No-op, as HTTP clients don't need explicit cleanup

> **Warning**: After calling `Close()`, the provider is no longer usable. Subsequent operations may panic or return errors.

## Error Handling

### Health Check Errors

```go
err := provider.Health(ctx)
if err != nil {
    switch {
    case errors.Is(err, context.DeadlineExceeded):
        // Health check timed out
    case errors.Is(err, context.Canceled):
        // Context was canceled
    default:
        // Backend-specific error (connection refused, auth failed, etc.)
    }
}
```

### Close Errors

```go
if err := provider.Close(ctx); err != nil {
    // Log but don't fail - we're shutting down anyway
    log.Printf("Warning: error closing provider: %v", err)
}
```

## Testing Lifecycle

```go
func TestLifecycle(t *testing.T) {
    provider := testing.NewMockProvider()

    // Health always succeeds for mock
    if err := provider.Health(context.Background()); err != nil {
        t.Fatalf("unexpected health error: %v", err)
    }

    // Close is safe to call
    if err := provider.Close(context.Background()); err != nil {
        t.Fatalf("unexpected close error: %v", err)
    }
}
```

## See Also

- **[Providers Guide](1.providers.md)** - Provider-specific configuration
- **[Best Practices](5.best-practices.md)** - Production recommendations
- **[API Reference](../5.reference/1.api.md)** - Complete Lifecycle interface documentation
