---
title: Lifecycle Operations
description: CRUD operations, batch processing, and listing
author: zoobzio
published: 2025-01-07
updated: 2025-01-07
tags:
  - Operations
  - CRUD
  - Lifecycle
---

# Lifecycle Operations

This guide covers the full lifecycle of data: create, read, update, delete, and list operations.

## Store Operations (Key-Value)

### Get

Retrieves a value by key.

```go
session, err := store.Get(ctx, "session:abc123")
if errors.Is(err, grub.ErrNotFound) {
    // Key doesn't exist
}
```

**Returns:** `(*T, error)`
- `ErrNotFound` if key doesn't exist

### Set

Stores a value with optional TTL.

```go
// With TTL (expires in 1 hour)
err := store.Set(ctx, "session:abc123", &session, time.Hour)

// Without TTL (never expires)
err := store.Set(ctx, "config:app", &config, 0)
```

**TTL behavior:**
- `ttl > 0`: Key expires after duration
- `ttl == 0`: No expiration
- BoltDB: Returns `ErrTTLNotSupported` if ttl > 0

### Delete

Removes a key.

```go
err := store.Delete(ctx, "session:abc123")
if errors.Is(err, grub.ErrNotFound) {
    // Key didn't exist
}
```

**Returns:** `ErrNotFound` if key doesn't exist

### Exists

Checks if a key exists without loading the value.

```go
exists, err := store.Exists(ctx, "session:abc123")
if exists {
    // Key exists
}
```

**Returns:** `(bool, error)` — never returns `ErrNotFound`

### List

Lists keys matching a prefix.

```go
// List up to 100 keys with prefix "session:"
keys, err := store.List(ctx, "session:", 100)

// List all keys (no limit)
keys, err := store.List(ctx, "", 0)
```

**Parameters:**
- `prefix`: Filter keys starting with this string (empty = all)
- `limit`: Maximum keys to return (0 = no limit)

### GetBatch

Retrieves multiple keys at once.

```go
keys := []string{"user:1", "user:2", "user:3"}
results, err := store.GetBatch(ctx, keys)

for key, user := range results {
    fmt.Println(key, user.Name)
}
```

**Behavior:** Missing keys are omitted from the result map (no error).

### SetBatch

Stores multiple values at once.

```go
items := map[string]*User{
    "user:1": {Name: "Alice"},
    "user:2": {Name: "Bob"},
}
err := store.SetBatch(ctx, items, time.Hour)
```

**Atomicity varies by provider:**
- Redis: Pipelined (each operation independent)
- Badger: WriteBatch (atomic)
- Bolt: Single transaction (atomic)

## Bucket Operations (Blob)

### Get

Retrieves an object with metadata.

```go
obj, err := bucket.Get(ctx, "docs/report.json")
if errors.Is(err, grub.ErrNotFound) {
    // Object doesn't exist
}

// Access payload
fmt.Println(obj.Data.Title)

// Access metadata
fmt.Println(obj.ContentType)
fmt.Println(obj.Size)
fmt.Println(obj.Metadata["author"])
```

### Put

Stores an object with metadata.

```go
err := bucket.Put(ctx, &grub.Object[Document]{
    Key:         "docs/report.json",
    ContentType: "application/json",
    Metadata:    map[string]string{"author": "alice", "version": "1.0"},
    Data:        Document{Title: "Q4 Report", Content: "..."},
})
```

**Note:** Size is computed from encoded data, not set manually.

### Delete

Removes an object.

```go
err := bucket.Delete(ctx, "docs/report.json")
if errors.Is(err, grub.ErrNotFound) {
    // Object didn't exist
}
```

### Exists

Checks if an object exists.

```go
exists, err := bucket.Exists(ctx, "docs/report.json")
```

### List

Lists objects matching a prefix (metadata only).

```go
infos, err := bucket.List(ctx, "docs/", 100)

for _, info := range infos {
    fmt.Printf("%s (%d bytes)\n", info.Key, info.Size)
}
```

**Returns:** `[]ObjectInfo` — metadata without payload

## Database Operations (SQL)

### Get

Retrieves a record by primary key.

```go
user, err := db.Get(ctx, "123")
if errors.Is(err, grub.ErrNotFound) {
    // Record doesn't exist
}
```

### Set

Upserts a record (insert or update on conflict).

```go
// Insert new record
err := db.Set(ctx, "123", &User{ID: "123", Name: "Alice"})

// Update existing record (same key)
err := db.Set(ctx, "123", &User{ID: "123", Name: "Alice Smith"})
```

**Behavior:** Always upserts. Uses `INSERT ... ON CONFLICT DO UPDATE`.

### Delete

Removes a record by primary key.

```go
err := db.Delete(ctx, "123")
if errors.Is(err, grub.ErrNotFound) {
    // Record didn't exist
}
```

### Exists

Checks if a record exists.

```go
exists, err := db.Exists(ctx, "123")
```

### Query

Executes a named query returning multiple records.

```go
// Query defined in edamame factory
users, err := db.Query(ctx, "active", nil)

// With parameters
users, err := db.Query(ctx, "by_role", map[string]any{"role": "admin"})
```

### Select

Executes a named query returning a single record.

```go
user, err := db.Select(ctx, "by_email", map[string]any{
    "email": "alice@example.com",
})
```

### Update

Executes a named update returning the modified record.

```go
user, err := db.Update(ctx, "deactivate", map[string]any{"id": "123"})
```

### Aggregate

Executes a named aggregate query.

```go
count, err := db.Aggregate(ctx, "count_active", nil)
```

## Common Patterns

### Check-Then-Act

```go
exists, _ := store.Exists(ctx, key)
if !exists {
    // Create default
    store.Set(ctx, key, defaultValue, 0)
}
```

**Warning:** Not atomic. For atomic operations, use provider-specific features.

### Get-Or-Create

```go
func GetOrCreate[T any](ctx context.Context, store *grub.Store[T], key string, create func() *T) (*T, error) {
    val, err := store.Get(ctx, key)
    if err == nil {
        return val, nil
    }
    if !errors.Is(err, grub.ErrNotFound) {
        return nil, err
    }

    val = create()
    if err := store.Set(ctx, key, val, 0); err != nil {
        return nil, err
    }
    return val, nil
}
```

### Batch Processing

```go
// Process in batches to avoid memory issues
const batchSize = 100

keys, _ := store.List(ctx, "user:", 0)

for i := 0; i < len(keys); i += batchSize {
    end := min(i+batchSize, len(keys))
    batch := keys[i:end]

    results, _ := store.GetBatch(ctx, batch)
    for key, user := range results {
        // Process user
    }
}
```

### Conditional Delete

```go
// Delete only if value matches condition
val, err := store.Get(ctx, key)
if err != nil {
    return err
}
if val.Status == "expired" {
    return store.Delete(ctx, key)
}
```

## Error Handling

### Standard Error Checks

```go
val, err := store.Get(ctx, key)
switch {
case err == nil:
    // Success
case errors.Is(err, grub.ErrNotFound):
    // Key doesn't exist
case errors.Is(err, context.DeadlineExceeded):
    // Timeout
case errors.Is(err, context.Canceled):
    // Canceled
default:
    // Provider error (network, etc.)
}
```

### Wrapping Errors

```go
val, err := store.Get(ctx, key)
if err != nil {
    return fmt.Errorf("loading config %s: %w", key, err)
}
```

The wrapped error preserves `errors.Is` behavior:

```go
if errors.Is(err, grub.ErrNotFound) {
    // Still works
}
```
