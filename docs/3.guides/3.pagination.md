---
title: Pagination Guide
description: Cursor-based pagination patterns for listing records
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - pagination
  - cursors
  - listing
---

# Pagination Guide

Grub uses cursor-based pagination for listing records. This guide covers pagination patterns, cursor handling, and best practices.

## The List Method

```go
List(ctx context.Context, cursor string, limit int) (keys []string, nextCursor string, err error)
```

- **cursor**: Empty string for first page, or value from previous `nextCursor`
- **limit**: Maximum records to return
- **keys**: Record keys for this page
- **nextCursor**: Pass to next call, empty when no more pages

## Basic Pagination

### Single Page

```go
keys, nextCursor, err := svc.List(ctx, "", 10)
if err != nil {
    return err
}

fmt.Printf("Found %d keys\n", len(keys))
if nextCursor != "" {
    fmt.Println("More pages available")
}
```

### Iterate All Pages

```go
func listAll(ctx context.Context, svc *grub.Service[User]) ([]string, error) {
    var allKeys []string
    cursor := ""

    for {
        keys, nextCursor, err := svc.List(ctx, cursor, 100)
        if err != nil {
            return nil, err
        }

        allKeys = append(allKeys, keys...)

        if nextCursor == "" {
            break
        }
        cursor = nextCursor
    }

    return allKeys, nil
}
```

### Iterate With Callback

```go
func forEach(ctx context.Context, svc *grub.Service[User], fn func(User) error) error {
    cursor := ""

    for {
        keys, nextCursor, err := svc.List(ctx, cursor, 100)
        if err != nil {
            return err
        }

        for _, key := range keys {
            record, err := svc.Get(ctx, key)
            if err != nil {
                return err
            }
            if err := fn(record); err != nil {
                return err
            }
        }

        if nextCursor == "" {
            return nil
        }
        cursor = nextCursor
    }
}
```

## Cursor Semantics

### Cursors Are Opaque

Treat cursors as opaque strings. Never:
- Parse or interpret cursor contents
- Construct cursors manually
- Assume cursor format across providers

```go
// Good
nextPage, _, _ := svc.List(ctx, previousCursor, 10)

// Bad - don't parse cursors
cursorNum, _ := strconv.Atoi(cursor)  // Will break!
```

### Cursors Are Provider-Specific

Different providers use different cursor formats internally:

| Provider | Internal Format | Example |
|----------|-----------------|---------|
| Redis | uint64 SCAN cursor | `"12345"` |
| S3 | AWS continuation token | `"1/..."` (opaque) |
| MongoDB | Last document ID | `"usr-123"` |
| DynamoDB | Last evaluated key | `"usr-123"` |
| BoltDB | Last key bytes | `"usr-123"` |

### Cursor Validity

Cursors may become invalid:
- After data mutations (inserts/deletes)
- After provider restarts (for some backends)
- After significant time (for token-based cursors)

Handle invalid cursors gracefully:

```go
keys, nextCursor, err := svc.List(ctx, cursor, 10)
if errors.Is(err, grub.ErrInvalidKey) {
    // Cursor invalid, restart from beginning
    keys, nextCursor, err = svc.List(ctx, "", 10)
}
```

## Pagination Patterns

### API Pagination

```go
type PageRequest struct {
    Cursor string `json:"cursor"`
    Limit  int    `json:"limit"`
}

type PageResponse struct {
    Items      []User `json:"items"`
    NextCursor string `json:"next_cursor,omitempty"`
    HasMore    bool   `json:"has_more"`
}

func handleList(w http.ResponseWriter, r *http.Request) {
    var req PageRequest
    json.NewDecoder(r.Body).Decode(&req)

    if req.Limit <= 0 || req.Limit > 100 {
        req.Limit = 20
    }

    keys, nextCursor, err := svc.List(r.Context(), req.Cursor, req.Limit)
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }

    // Fetch records for keys
    items := make([]User, 0, len(keys))
    for _, key := range keys {
        user, err := svc.Get(r.Context(), key)
        if err == nil {
            items = append(items, user)
        }
    }

    resp := PageResponse{
        Items:      items,
        NextCursor: nextCursor,
        HasMore:    nextCursor != "",
    }

    json.NewEncoder(w).Encode(resp)
}
```

### Batch Processing

```go
func processBatch(ctx context.Context, svc *grub.Service[Job]) error {
    cursor := ""
    batchSize := 50

    for {
        keys, nextCursor, err := svc.List(ctx, cursor, batchSize)
        if err != nil {
            return err
        }

        // Process batch concurrently
        var wg sync.WaitGroup
        errs := make(chan error, len(keys))

        for _, key := range keys {
            wg.Add(1)
            go func(k string) {
                defer wg.Done()
                if err := processJob(ctx, svc, k); err != nil {
                    errs <- err
                }
            }(key)
        }

        wg.Wait()
        close(errs)

        // Check for errors
        for err := range errs {
            return err
        }

        if nextCursor == "" {
            return nil
        }
        cursor = nextCursor
    }
}
```

### Streaming Results

```go
func streamKeys(ctx context.Context, svc *grub.Service[User]) <-chan string {
    ch := make(chan string)

    go func() {
        defer close(ch)
        cursor := ""

        for {
            keys, nextCursor, err := svc.List(ctx, cursor, 100)
            if err != nil {
                return
            }

            for _, key := range keys {
                select {
                case ch <- key:
                case <-ctx.Done():
                    return
                }
            }

            if nextCursor == "" {
                return
            }
            cursor = nextCursor
        }
    }()

    return ch
}

// Usage
for key := range streamKeys(ctx, users) {
    fmt.Println(key)
}
```

## Page Size Considerations

### Choosing Limit

| Use Case | Recommended Limit | Reason |
|----------|-------------------|--------|
| API response | 20-50 | Balance latency and payload size |
| Batch processing | 100-500 | Minimize round trips |
| Full export | 1000 | Maximum efficiency |
| Interactive UI | 10-20 | Fast initial load |

### Provider Limits

Some providers have maximum page sizes:

| Provider | Max Limit | Notes |
|----------|-----------|-------|
| S3 | 1000 | AWS API limit |
| DynamoDB | 1MB data | May return fewer items |
| Firestore | Varies | Depends on document size |

Grub doesn't enforce limits - providers return what they can.

## Ordering

### Default Order

List order depends on the provider:

| Provider | Order |
|----------|-------|
| Redis | Undefined (hash-based) |
| S3 | Lexicographic by key |
| MongoDB | By `_id` (ascending) |
| DynamoDB | Undefined (scan order) |
| BoltDB | Lexicographic by key |
| BadgerDB | Lexicographic by key |

### Consistent Ordering

For consistent ordering, use keys that sort naturally:

```go
// Time-ordered keys
key := fmt.Sprintf("%s_%s", time.Now().Format("20060102150405"), uuid.New())

// Padded numeric keys
key := fmt.Sprintf("item-%010d", itemNumber)
```

## Performance Considerations

### Count vs List

`Count()` may be expensive for large datasets:

```go
// This might scan entire dataset
count, _ := svc.Count(ctx)

// Consider tracking count separately for large datasets
```

### Avoid Deep Pagination

Deep pagination (high offset) is inefficient with cursors. If users need to jump to page 100, consider:

- Filtering by key prefix
- Time-based partitioning
- Search/index service

### Parallel Fetching

After listing keys, fetch records in parallel:

```go
keys, _, _ := svc.List(ctx, cursor, 50)

results := make([]User, len(keys))
var wg sync.WaitGroup

for i, key := range keys {
    wg.Add(1)
    go func(idx int, k string) {
        defer wg.Done()
        results[idx], _ = svc.Get(ctx, k)
    }(i, key)
}

wg.Wait()
```

## See Also

- **[Concepts](../2.learn/2.concepts.md)** - Understanding the Provider interface
- **[Architecture](../2.learn/3.architecture.md)** - How cursor pagination is implemented
- **[API Reference](../5.reference/1.api.md)** - List method documentation
