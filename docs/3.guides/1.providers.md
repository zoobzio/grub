---
title: Providers Guide
description: Configuring and using each storage backend
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - providers
  - configuration
  - backends
---

# Providers Guide

This guide covers configuration and usage for each grub provider. Choose a provider based on your infrastructure, performance needs, and operational requirements.

## Provider Comparison

| Provider | Type | Latency | Scale | Cost Model | Best For |
|----------|------|---------|-------|------------|----------|
| Redis | In-memory | μs | Medium | Memory | Caching, sessions |
| S3 | Object | ms | Unlimited | Storage + requests | Documents, backups |
| MongoDB | Document | ms | High | Compute + storage | Flexible schemas |
| DynamoDB | Serverless | ms | Unlimited | Requests + storage | Auto-scaling |
| Firestore | Document | ms | High | Reads + writes | Real-time, mobile |
| GCS | Object | ms | Unlimited | Storage + requests | Google Cloud |
| Azure Blob | Object | ms | Unlimited | Storage + requests | Azure ecosystem |
| BoltDB | Embedded | μs | Single node | None | Local apps |
| BadgerDB | Embedded | μs | Single node | None | High-perf local |

## Redis

In-memory data store. Ideal for caching, sessions, and any use case requiring sub-millisecond latency.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/redis
```

### Configuration

```go
import (
    "github.com/redis/go-redis/v9"
    grubRedis "github.com/zoobzio/grub/pkg/redis"
)

// Standard Redis
client := redis.NewClient(&redis.Options{
    Addr:     "localhost:6379",
    Password: "",
    DB:       0,
})

// Cluster
client := redis.NewClusterClient(&redis.ClusterOptions{
    Addrs: []string{"node1:6379", "node2:6379", "node3:6379"},
})

// Create provider with key prefix
provider := grubRedis.New(client, "myapp:users:")
```

### Key Prefixing

All keys are automatically prefixed. If your prefix is `myapp:users:`, a key `usr-123` becomes `myapp:users:usr-123` in Redis.

### Health Check

```go
err := provider.Health(ctx)  // Sends PING command
```

### Considerations

- **Memory limits**: Monitor memory usage; Redis evicts keys when full
- **Persistence**: Configure RDB/AOF for durability if needed
- **Key expiration**: Grub doesn't set TTLs; manage expiration separately if needed

---

## S3

Amazon S3 object storage. Ideal for documents, media, backups, and any large or infrequently accessed data.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/s3
```

### Configuration

```go
import (
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/s3"
    grubS3 "github.com/zoobzio/grub/pkg/s3"
)

cfg, err := config.LoadDefaultConfig(ctx)
if err != nil {
    log.Fatal(err)
}

client := s3.NewFromConfig(cfg)
provider := grubS3.New(client, "my-bucket", "data/users/")
```

### Object Keys

Objects are stored at `prefix + key`. With prefix `data/users/` and key `usr-123`, the S3 object key is `data/users/usr-123`.

### Health Check

```go
err := provider.Health(ctx)  // Calls HeadBucket
```

### Considerations

- **Eventual consistency**: S3 is now strongly consistent for most operations
- **Request costs**: List and Get operations incur per-request charges
- **Large objects**: Grub stores entire objects; for large files, consider multipart uploads outside grub

---

## MongoDB

Document database with rich querying. Ideal for flexible schemas and complex query requirements.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/mongo
```

### Configuration

```go
import (
    "go.mongodb.org/mongo-driver/v2/mongo"
    "go.mongodb.org/mongo-driver/v2/mongo/options"
    grubMongo "github.com/zoobzio/grub/pkg/mongo"
)

client, err := mongo.Connect(options.Client().ApplyURI("mongodb://localhost:27017"))
if err != nil {
    log.Fatal(err)
}

collection := client.Database("myapp").Collection("users")
provider := grubMongo.New(collection)
```

### Document Structure

Documents are stored as:

```json
{
    "_id": "usr-123",
    "data": <binary bytes>
}
```

The `_id` field is your key; `data` contains the serialized record.

### Health Check

```go
err := provider.Health(ctx)  // Calls Ping
```

### Considerations

- **Indexes**: The `_id` field is automatically indexed
- **Document size**: MongoDB has a 16MB document limit
- **Connection pooling**: The driver handles pooling; configure `MaxPoolSize` as needed

---

## DynamoDB

AWS serverless database. Ideal for auto-scaling workloads and serverless architectures.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/dynamo
```

### Configuration

```go
import (
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb"
    grubDynamo "github.com/zoobzio/grub/pkg/dynamo"
)

cfg, err := config.LoadDefaultConfig(ctx)
if err != nil {
    log.Fatal(err)
}

client := dynamodb.NewFromConfig(cfg)
provider := grubDynamo.New(client, "my-table")
```

### Table Schema

Your DynamoDB table must have a partition key named `pk` of type String:

```
Table: my-table
  Partition Key: pk (String)
```

Items are stored as:

```json
{
    "pk": "usr-123",
    "data": <binary>
}
```

### Health Check

```go
err := provider.Health(ctx)  // Calls DescribeTable
```

### Considerations

- **Capacity modes**: Choose on-demand for variable workloads, provisioned for predictable
- **Item size**: 400KB limit per item
- **Scan costs**: `List` and `Count` use Scan, which reads the entire table

---

## Firestore

Google Cloud document database with real-time sync. Ideal for mobile apps and real-time features.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/firestore
```

### Configuration

```go
import (
    "cloud.google.com/go/firestore"
    grubFirestore "github.com/zoobzio/grub/pkg/firestore"
)

client, err := firestore.NewClient(ctx, "my-project")
if err != nil {
    log.Fatal(err)
}

provider := grubFirestore.New(client, "users")
```

### Document Structure

Documents are stored with document ID as the key:

```
Collection: users
  Document: usr-123
    data: <bytes>
```

### Health Check

```go
err := provider.Health(ctx)  // Lists 1 document
```

### Considerations

- **Pricing**: Charged per read/write operation
- **Offline support**: Firestore SDKs support offline; grub uses the server SDK
- **Real-time**: For real-time updates, use Firestore listeners directly

---

## GCS

Google Cloud Storage. Ideal for Google Cloud workloads and large object storage.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/gcs
```

### Configuration

```go
import (
    "cloud.google.com/go/storage"
    grubGCS "github.com/zoobzio/grub/pkg/gcs"
)

client, err := storage.NewClient(ctx)
if err != nil {
    log.Fatal(err)
}

provider := grubGCS.New(client, "my-bucket", "data/users/")
```

### Health Check

```go
err := provider.Health(ctx)  // Fetches bucket attributes
```

### Considerations

- **Similar to S3**: GCS and S3 have similar semantics and pricing models
- **Interoperability**: GCS supports S3-compatible API if needed

---

## Azure Blob

Azure Blob Storage. Ideal for Azure ecosystem and enterprise workloads.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/azure
```

### Configuration

```go
import (
    "github.com/Azure/azure-sdk-for-go/sdk/storage/azblob"
    grubAzure "github.com/zoobzio/grub/pkg/azure"
)

// Using connection string
client, err := azblob.NewClientFromConnectionString(connectionString, nil)
if err != nil {
    log.Fatal(err)
}

provider := grubAzure.New(client, "my-container", "data/users/")
```

### Health Check

```go
err := provider.Health(ctx)  // Gets container properties
```

### Considerations

- **Access tiers**: Hot, Cool, Archive affect pricing and latency
- **Soft delete**: Enable for accidental deletion protection

---

## BoltDB

Embedded key-value store using bbolt. Ideal for local applications without external infrastructure.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/bolt
```

### Configuration

```go
import (
    bolt "go.etcd.io/bbolt"
    grubBolt "github.com/zoobzio/grub/pkg/bolt"
)

db, err := bolt.Open("data.db", 0600, nil)
if err != nil {
    log.Fatal(err)
}

provider, err := grubBolt.New(db, "users")
if err != nil {
    log.Fatal(err)
}
```

### Bucket Isolation

Each provider is scoped to a BoltDB bucket. The bucket is created automatically if it doesn't exist.

### Health Check

```go
err := provider.Health(ctx)  // Performs read transaction
```

### Considerations

- **Single writer**: BoltDB allows one writer at a time
- **File locking**: Only one process can open the database
- **Backup**: Copy the file while holding a read transaction

---

## BadgerDB

High-performance embedded database using LSM trees. Ideal for write-heavy local workloads.

### Installation

```bash
go get github.com/zoobzio/grub/pkg/badger
```

### Configuration

```go
import (
    "github.com/dgraph-io/badger/v4"
    grubBadger "github.com/zoobzio/grub/pkg/badger"
)

db, err := badger.Open(badger.DefaultOptions("./data"))
if err != nil {
    log.Fatal(err)
}

provider := grubBadger.New(db, "users:")
```

### Key Prefixing

BadgerDB uses key prefixes (similar to Redis) for isolation.

### Health Check

```go
err := provider.Health(ctx)  // Performs read transaction
```

### Considerations

- **Garbage collection**: Run `db.RunValueLogGC()` periodically
- **Memory usage**: LSM trees use memory for write buffers
- **Compaction**: Background compaction may affect performance

---

## See Also

- **[Lifecycle Guide](2.lifecycle.md)** - Connection management and health checks
- **[Testing Guide](4.testing.md)** - Using MockProvider for tests
- **[Provider Reference](../5.reference/2.providers.md)** - Detailed API for each provider
