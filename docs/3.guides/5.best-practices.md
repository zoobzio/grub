---
title: Best Practices
description: Production recommendations for using grub effectively
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - best-practices
  - production
  - recommendations
---

# Best Practices

This guide covers production recommendations for using grub effectively.

## Key Design

### Use Meaningful Keys

Keys should be human-readable and debuggable:

```go
// Good
"user:usr-a1b2c3d4"
"order:ord-2024-001234"
"session:sess-xyz789"

// Avoid
"a1b2c3d4"           // No context
"12345"              // Numeric only
"user_a1b2c3d4"      // Inconsistent separator
```

### Include Type Prefixes

Prefix keys with their type for clarity:

```go
// Good - clear what each key represents
users := grub.New[User](provider)
users.Set(ctx, "usr-123", user)

orders := grub.New[Order](provider)
orders.Set(ctx, "ord-456", order)
```

### Avoid Key Collisions

With shared providers, ensure key spaces don't overlap:

```go
// Services share provider's key scope
users := grub.New[User](provider)
admins := grub.New[User](provider)  // Use different providers for true isolation
```

### Use Sortable Keys for Time-Series

For time-ordered data, use keys that sort lexicographically:

```go
// Good - sorts chronologically
key := fmt.Sprintf("event:%s:%s", time.Now().Format("20060102150405"), eventID)

// Good - padded numbers sort correctly
key := fmt.Sprintf("seq:%010d", sequenceNumber)
```

## Error Handling

### Always Check Errors

```go
// Good
user, err := users.Get(ctx, id)
if err != nil {
    if errors.Is(err, grub.ErrNotFound) {
        return nil, ErrUserNotFound
    }
    return nil, fmt.Errorf("failed to get user: %w", err)
}

// Avoid
user, _ := users.Get(ctx, id)  // Silent failure
```

### Handle ErrNotFound Explicitly

```go
user, err := users.Get(ctx, id)
switch {
case errors.Is(err, grub.ErrNotFound):
    // Expected case - handle gracefully
    return nil, nil
case err != nil:
    // Unexpected error - propagate
    return nil, err
}
```

### Wrap Errors With Context

```go
if err := users.Set(ctx, user.ID, user); err != nil {
    return fmt.Errorf("saving user %s: %w", user.ID, err)
}
```

## Lifecycle Management

### Always Close Providers

```go
func main() {
    provider := redis.New(client, "myapp:")
    defer provider.Close(context.Background())

    // ...
}
```

### Use Health Checks

```go
// Startup check
if err := provider.Health(ctx); err != nil {
    log.Fatalf("Provider not ready: %v", err)
}

// Readiness probe
http.HandleFunc("/ready", func(w http.ResponseWriter, r *http.Request) {
    if err := provider.Health(r.Context()); err != nil {
        w.WriteHeader(http.StatusServiceUnavailable)
        return
    }
    w.WriteHeader(http.StatusOK)
})
```

### Handle Shutdown Gracefully

```go
sigCh := make(chan os.Signal, 1)
signal.Notify(sigCh, syscall.SIGTERM, syscall.SIGINT)

<-sigCh

ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

if err := provider.Close(ctx); err != nil {
    log.Printf("Error during shutdown: %v", err)
}
```

## Context Usage

### Pass Context Through

```go
// Good - propagates cancellation and deadlines
func (s *Service) GetUser(ctx context.Context, id string) (*User, error) {
    return s.users.Get(ctx, id)
}

// Avoid - loses context
func (s *Service) GetUser(id string) (*User, error) {
    return s.users.Get(context.Background(), id)
}
```

### Set Timeouts for Operations

```go
ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
defer cancel()

user, err := users.Get(ctx, id)
if errors.Is(err, context.DeadlineExceeded) {
    // Handle timeout
}
```

## Provider Selection

### Match Provider to Use Case

| Use Case | Recommended | Why |
|----------|-------------|-----|
| Session storage | Redis | Fast, built-in expiration |
| User profiles | MongoDB, DynamoDB | Flexible schema, scalable |
| File metadata | S3, GCS | Colocated with files |
| Local cache | BoltDB, BadgerDB | No network, fast |
| Serverless | DynamoDB | Auto-scaling, pay-per-use |

### Don't Over-Abstract

Sometimes direct backend access is appropriate:

```go
// Grub is great for CRUD
user, _ := users.Get(ctx, id)

// But use native queries for complex operations
results, _ := mongoCollection.Find(ctx, bson.M{
    "status": "active",
    "created": bson.M{"$gte": lastWeek},
})
```

## Performance

### Batch Fetches When Possible

```go
// Good - parallel fetches
keys, _, _ := svc.List(ctx, "", 100)

var wg sync.WaitGroup
results := make([]User, len(keys))

for i, key := range keys {
    wg.Add(1)
    go func(idx int, k string) {
        defer wg.Done()
        results[idx], _ = svc.Get(ctx, k)
    }(i, key)
}
wg.Wait()

// Avoid - sequential fetches
for _, key := range keys {
    user, _ := svc.Get(ctx, key)  // One at a time
    results = append(results, user)
}
```

### Use Appropriate Page Sizes

```go
// API responses: 20-50
keys, _, _ := svc.List(ctx, cursor, 25)

// Batch processing: 100-500
keys, _, _ := svc.List(ctx, cursor, 200)

// Exports: 500-1000
keys, _, _ := svc.List(ctx, cursor, 1000)
```

### Avoid Count on Large Datasets

```go
// This scans the entire dataset
count, _ := svc.Count(ctx)  // Expensive!

// Consider tracking count separately
atomic.AddInt64(&itemCount, 1)
```

## Testing

### Use MockProvider for Unit Tests

```go
func TestUserCreation(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    users := grub.New[User](provider)

    // Fast, no external dependencies
}
```

### Reset State Between Tests

```go
func TestSuite(t *testing.T) {
    provider := grubtesting.NewMockProvider()

    t.Run("test1", func(t *testing.T) {
        provider.Reset()
        // ...
    })
}
```

### Test Error Paths

```go
func TestGetNotFound(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    users := grub.New[User](provider)

    _, err := users.Get(context.Background(), "nonexistent")

    if !errors.Is(err, grub.ErrNotFound) {
        t.Errorf("expected ErrNotFound, got %v", err)
    }
}
```

## Observability

### Hook Into Signals

```go
capitan.Hook(grub.GetFailed, func(ctx context.Context, e *capitan.Event) {
    key := grub.FieldKey.From(e)
    err := grub.FieldError.From(e)
    log.Printf("Get failed for %s: %s", key, err)
})
```

### Track Latencies

```go
capitan.Hook(grub.GetCompleted, func(ctx context.Context, e *capitan.Event) {
    duration := grub.FieldDuration.From(e)
    metrics.RecordHistogram("grub.get.latency", duration.Seconds())
})
```

## Schema Evolution

### Design for Change

```go
type User struct {
    ID      string `json:"id"`
    Name    string `json:"name"`
    Email   string `json:"email"`
    Version int    `json:"version"`  // Track schema version
}
```

### Handle Missing Fields

```go
type User struct {
    ID       string  `json:"id"`
    Name     string  `json:"name"`
    Nickname *string `json:"nickname,omitempty"`  // Optional, added later
}
```

### Migrate Gradually

```go
func (s *Service) GetUser(ctx context.Context, id string) (*User, error) {
    user, err := s.users.Get(ctx, id)
    if err != nil {
        return nil, err
    }

    // Migrate old records on read
    if user.Version < 2 {
        user = migrateUserV1ToV2(user)
        s.users.Set(ctx, user.ID, user)  // Update in place
    }

    return &user, nil
}
```

## Security

### Don't Store Secrets

```go
// Avoid
type Config struct {
    APIKey   string `json:"api_key"`    // Don't store in grub
    Password string `json:"password"`   // Don't store in grub
}

// Better - reference secrets by ID
type Config struct {
    SecretRef string `json:"secret_ref"`  // "vault:secret/myapp"
}
```

### Validate Keys

```go
func (s *Service) Get(ctx context.Context, id string) (*User, error) {
    // Validate ID format
    if !isValidUserID(id) {
        return nil, ErrInvalidID
    }
    return s.users.Get(ctx, id)
}
```

### Sanitize User Input

```go
func (s *Service) Set(ctx context.Context, user User) error {
    // Sanitize before storing
    user.Name = sanitize(user.Name)
    user.Email = strings.ToLower(strings.TrimSpace(user.Email))

    return s.users.Set(ctx, user.ID, user)
}
```

## See Also

- **[Lifecycle Guide](2.lifecycle.md)** - Connection management patterns
- **[Testing Guide](4.testing.md)** - Testing strategies
- **[Providers Guide](1.providers.md)** - Provider-specific recommendations
