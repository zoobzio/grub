---
title: Testing Guide
description: Using MockProvider and testing patterns for grub
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - testing
  - mocking
  - unit-tests
---

# Testing Guide

Grub provides a `MockProvider` for unit testing without external dependencies. This guide covers testing patterns and best practices.

## MockProvider

### Installation

The testing utilities are in the `testing` subpackage:

```go
import grubtesting "github.com/zoobzio/grub/testing"
```

### Basic Usage

```go
func TestUserService(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    users := grub.New[User](provider)

    ctx := context.Background()

    // Create
    user := User{ID: "usr-123", Name: "Alice"}
    err := users.Set(ctx, user.ID, user)
    if err != nil {
        t.Fatalf("Set failed: %v", err)
    }

    // Read
    got, err := users.Get(ctx, "usr-123")
    if err != nil {
        t.Fatalf("Get failed: %v", err)
    }
    if got.Name != "Alice" {
        t.Errorf("expected Alice, got %s", got.Name)
    }
}
```

### Reset Between Tests

```go
func TestSuite(t *testing.T) {
    provider := grubtesting.NewMockProvider()

    t.Run("test1", func(t *testing.T) {
        provider.Reset()  // Clear data from previous tests
        // ...
    })

    t.Run("test2", func(t *testing.T) {
        provider.Reset()
        // ...
    })
}
```

## Testing CRUD Operations

### Test Create

```go
func TestCreate(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[Item](provider)
    ctx := context.Background()

    item := Item{ID: "item-1", Value: 100}
    err := svc.Set(ctx, item.ID, item)

    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Verify stored
    exists, _ := svc.Exists(ctx, item.ID)
    if !exists {
        t.Error("item should exist after Set")
    }
}
```

### Test Read

```go
func TestRead(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[Item](provider)
    ctx := context.Background()

    // Setup
    item := Item{ID: "item-1", Value: 100}
    svc.Set(ctx, item.ID, item)

    // Test Get
    got, err := svc.Get(ctx, item.ID)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if got.Value != 100 {
        t.Errorf("expected Value=100, got %d", got.Value)
    }
}
```

### Test Not Found

```go
func TestNotFound(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[Item](provider)
    ctx := context.Background()

    _, err := svc.Get(ctx, "nonexistent")

    if !errors.Is(err, grub.ErrNotFound) {
        t.Errorf("expected ErrNotFound, got %v", err)
    }
}
```

### Test Delete

```go
func TestDelete(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[Item](provider)
    ctx := context.Background()

    // Setup
    svc.Set(ctx, "item-1", Item{ID: "item-1"})

    // Delete
    err := svc.Delete(ctx, "item-1")
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Verify deleted
    exists, _ := svc.Exists(ctx, "item-1")
    if exists {
        t.Error("item should not exist after Delete")
    }
}

func TestDeleteNotFound(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[Item](provider)
    ctx := context.Background()

    err := svc.Delete(ctx, "nonexistent")

    if !errors.Is(err, grub.ErrNotFound) {
        t.Errorf("expected ErrNotFound, got %v", err)
    }
}
```

### Test List

```go
func TestList(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[Item](provider)
    ctx := context.Background()

    // Setup
    for i := 1; i <= 5; i++ {
        svc.Set(ctx, fmt.Sprintf("item-%d", i), Item{ID: fmt.Sprintf("item-%d", i)})
    }

    // List all
    keys, nextCursor, err := svc.List(ctx, "", 10)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if len(keys) != 5 {
        t.Errorf("expected 5 keys, got %d", len(keys))
    }
    if nextCursor != "" {
        t.Error("expected empty cursor (no more pages)")
    }
}

func TestListPagination(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[Item](provider)
    ctx := context.Background()

    // Setup
    for i := 1; i <= 10; i++ {
        svc.Set(ctx, fmt.Sprintf("item-%02d", i), Item{})
    }

    // First page
    keys1, cursor1, _ := svc.List(ctx, "", 3)
    if len(keys1) != 3 {
        t.Errorf("expected 3 keys, got %d", len(keys1))
    }
    if cursor1 == "" {
        t.Error("expected non-empty cursor")
    }

    // Second page
    keys2, cursor2, _ := svc.List(ctx, cursor1, 3)
    if len(keys2) != 3 {
        t.Errorf("expected 3 keys, got %d", len(keys2))
    }

    // Verify no overlap
    for _, k := range keys1 {
        for _, k2 := range keys2 {
            if k == k2 {
                t.Errorf("duplicate key across pages: %s", k)
            }
        }
    }
}
```

## Testing Lifecycle

```go
func TestLifecycle(t *testing.T) {
    provider := grubtesting.NewMockProvider()

    // Connect is no-op
    if err := provider.Connect(context.Background()); err != nil {
        t.Errorf("Connect failed: %v", err)
    }

    // Health always succeeds
    if err := provider.Health(context.Background()); err != nil {
        t.Errorf("Health failed: %v", err)
    }

    // Close is no-op
    if err := provider.Close(context.Background()); err != nil {
        t.Errorf("Close failed: %v", err)
    }
}
```

## Testing Application Logic

### Service Layer Testing

```go
// Application code
type UserService struct {
    store *grub.Service[User]
}

func (s *UserService) CreateUser(ctx context.Context, name, email string) (*User, error) {
    user := User{
        ID:    uuid.New().String(),
        Name:  name,
        Email: email,
    }
    if err := s.store.Set(ctx, user.ID, user); err != nil {
        return nil, err
    }
    return &user, nil
}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    user, err := s.store.Get(ctx, id)
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// Test
func TestUserService_CreateUser(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    store := grub.New[User](provider)
    svc := &UserService{store: store}

    user, err := svc.CreateUser(context.Background(), "Alice", "alice@example.com")

    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if user.Name != "Alice" {
        t.Errorf("expected Alice, got %s", user.Name)
    }

    // Verify persisted
    got, _ := svc.GetUser(context.Background(), user.ID)
    if got.Email != "alice@example.com" {
        t.Errorf("expected alice@example.com, got %s", got.Email)
    }
}
```

### Handler Testing

```go
func TestGetUserHandler(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    store := grub.New[User](provider)

    // Setup test data
    store.Set(context.Background(), "usr-123", User{
        ID:   "usr-123",
        Name: "Alice",
    })

    // Create request
    req := httptest.NewRequest("GET", "/users/usr-123", nil)
    rec := httptest.NewRecorder()

    // Handle
    handler := GetUserHandler(store)
    handler.ServeHTTP(rec, req)

    // Assert
    if rec.Code != http.StatusOK {
        t.Errorf("expected 200, got %d", rec.Code)
    }

    var user User
    json.Unmarshal(rec.Body.Bytes(), &user)
    if user.Name != "Alice" {
        t.Errorf("expected Alice, got %s", user.Name)
    }
}
```

## Event Capture

Test observability signals with `EventCapture`:

```go
func TestEmitsEvents(t *testing.T) {
    provider := grubtesting.NewMockProvider()
    svc := grub.New[User](provider)
    capture := grubtesting.NewEventCapture()

    // Hook into signals
    ctx := capitan.WithCallback(context.Background(), capture.Handler())

    // Perform operation
    svc.Set(ctx, "usr-123", User{ID: "usr-123"})

    // Verify events
    events := capture.Events()
    if len(events) == 0 {
        t.Error("expected events to be captured")
    }

    // Check specific signal
    setEvents := capture.EventsBySignal(grub.SetCompleted)
    if len(setEvents) == 0 {
        t.Error("expected SetCompleted event")
    }
}
```

## Table-Driven Tests

```go
func TestCRUD(t *testing.T) {
    tests := []struct {
        name    string
        setup   func(*grub.Service[Item])
        action  func(*grub.Service[Item]) error
        wantErr error
    }{
        {
            name:   "get existing",
            setup:  func(s *grub.Service[Item]) { s.Set(context.Background(), "k", Item{}) },
            action: func(s *grub.Service[Item]) error { _, err := s.Get(context.Background(), "k"); return err },
        },
        {
            name:    "get missing",
            setup:   func(s *grub.Service[Item]) {},
            action:  func(s *grub.Service[Item]) error { _, err := s.Get(context.Background(), "k"); return err },
            wantErr: grub.ErrNotFound,
        },
        {
            name:   "delete existing",
            setup:  func(s *grub.Service[Item]) { s.Set(context.Background(), "k", Item{}) },
            action: func(s *grub.Service[Item]) error { return s.Delete(context.Background(), "k") },
        },
        {
            name:    "delete missing",
            setup:   func(s *grub.Service[Item]) {},
            action:  func(s *grub.Service[Item]) error { return s.Delete(context.Background(), "k") },
            wantErr: grub.ErrNotFound,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            provider := grubtesting.NewMockProvider()
            svc := grub.New[Item](provider)

            tt.setup(svc)
            err := tt.action(svc)

            if tt.wantErr != nil {
                if !errors.Is(err, tt.wantErr) {
                    t.Errorf("expected %v, got %v", tt.wantErr, err)
                }
            } else if err != nil {
                t.Errorf("unexpected error: %v", err)
            }
        })
    }
}
```

## Integration Testing

For integration tests with real backends, use build tags:

```go
//go:build integration

package myapp_test

import (
    "testing"
    "github.com/redis/go-redis/v9"
    grubRedis "github.com/zoobzio/grub/pkg/redis"
)

func TestWithRealRedis(t *testing.T) {
    client := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    defer client.Close()

    provider := grubRedis.New(client, "test:")
    // ... test with real provider
}
```

Run with:

```bash
go test -tags=integration ./...
```

## See Also

- **[Best Practices](5.best-practices.md)** - Testing recommendations
- **[API Reference](../5.reference/1.api.md)** - MockProvider documentation
- **[Testing Reference](../5.reference/1.api.md#testing)** - Complete testing utilities
