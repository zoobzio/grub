---
title: Core Concepts
description: Stores, buckets, databases, and the primitives that power grub
author: zoobzio
published: 2025-01-07
updated: 2025-01-07
tags:
  - Concepts
  - Store
  - Bucket
  - Database
---

# Core Concepts

Grub has three storage modes, each with a type-safe wrapper and provider interface.

## Storage Modes

| Mode | Wrapper | Provider Interface | Use Case |
|------|---------|-------------------|----------|
| Key-Value | `Store[T]` | `StoreProvider` | Sessions, cache, config |
| Blob | `Bucket[T]` | `BucketProvider` | Files, media, documents |
| SQL | `Database[T]` | edamame.Factory | Structured records |

## Stores (Key-Value)

Stores map string keys to typed values with optional TTL.

### StoreProvider Interface

Providers implement raw byte operations:

```go
type StoreProvider interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    List(ctx context.Context, prefix string, limit int) ([]string, error)
    GetBatch(ctx context.Context, keys []string) (map[string][]byte, error)
    SetBatch(ctx context.Context, items map[string][]byte, ttl time.Duration) error
}
```

### Store[T] Wrapper

The wrapper adds type safety and serialization:

```go
store := grub.NewStore[Session](redis.New(client))

// All operations are type-safe
session, err := store.Get(ctx, "key")      // Returns *Session
err = store.Set(ctx, "key", &session, ttl) // Accepts *Session
exists, err := store.Exists(ctx, "key")    // Returns bool
keys, err := store.List(ctx, "prefix:", 0) // Returns []string
```

### TTL Behavior

- `ttl > 0` — Key expires after duration
- `ttl == 0` — No expiration
- BoltDB does not support TTL (returns `ErrTTLNotSupported`)

## Buckets (Blob Storage)

Buckets store objects with metadata (content type, size, custom headers).

### BucketProvider Interface

```go
type BucketProvider interface {
    Get(ctx context.Context, key string) ([]byte, *ObjectInfo, error)
    Put(ctx context.Context, key string, data []byte, info *ObjectInfo) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    List(ctx context.Context, prefix string, limit int) ([]ObjectInfo, error)
}
```

### Object[T] Structure

Objects combine metadata with typed payload:

```go
type Object[T any] struct {
    Key         string            // Required: object path
    ContentType string            // MIME type
    Size        int64             // Computed from encoded data
    ETag        string            // Version identifier
    Metadata    map[string]string // Custom headers
    Data        T                 // Your typed payload
}
```

### Bucket[T] Wrapper

```go
bucket := grub.NewBucket[Document](s3.New(client, "bucket"))

// Put stores the object
err := bucket.Put(ctx, &grub.Object[Document]{
    Key:         "docs/file.json",
    ContentType: "application/json",
    Metadata:    map[string]string{"author": "alice"},
    Data:        Document{Title: "Hello"},
})

// Get returns Object with typed Data
obj, err := bucket.Get(ctx, "docs/file.json")
fmt.Println(obj.Data.Title)     // "Hello"
fmt.Println(obj.Metadata["author"]) // "alice"
```

### ObjectInfo (Metadata Only)

For listing without loading payload:

```go
type ObjectInfo struct {
    Key         string
    ContentType string
    Size        int64
    ETag        string
    Metadata    map[string]string
}

// List returns metadata only
infos, _ := bucket.List(ctx, "docs/", 100)
for _, info := range infos {
    fmt.Println(info.Key, info.Size)
}
```

## Databases (SQL)

Databases provide CRUD operations on SQL tables with query capabilities.

### Database[T] Constructor

```go
db, err := grub.NewDatabase[User](
    sqlxDB,        // *sqlx.DB connection
    "users",       // Table name
    "id",          // Primary key column
    sqlite.New(),  // SQL dialect renderer
)
```

### Operations

```go
// CRUD via key
user, err := db.Get(ctx, "123")
err = db.Set(ctx, "123", &User{ID: "123", Name: "Alice"})
err = db.Delete(ctx, "123")
exists, err := db.Exists(ctx, "123")

// Named queries (defined via edamame)
users, err := db.Query(ctx, "active", nil)
user, err := db.Select(ctx, "by_email", map[string]any{"email": "alice@example.com"})
```

### Set Behavior

`Set` performs an upsert (insert or update on conflict):

```go
// First call inserts
db.Set(ctx, "1", &User{ID: "1", Name: "Alice"})

// Second call updates
db.Set(ctx, "1", &User{ID: "1", Name: "Alice Smith"})
```

## Codecs

Codecs handle serialization between typed values and bytes.

### Built-in Codecs

| Codec | Format | Use Case |
|-------|--------|----------|
| `JSONCodec` | JSON | Default, portable, human-readable |
| `GobCodec` | Gob | Go-specific, more compact |

### Custom Codec

```go
// Use Gob instead of JSON
store := grub.NewStoreWithCodec[Config](
    provider,
    grub.GobCodec{},
)
```

### Codec Interface

```go
type Codec interface {
    Encode(v any) ([]byte, error)
    Decode(data []byte, v any) error
}
```

## Semantic Errors

All providers return consistent error types:

| Error | Meaning |
|-------|---------|
| `ErrNotFound` | Record does not exist |
| `ErrDuplicate` | Key already exists |
| `ErrConflict` | Concurrent modification |
| `ErrConstraint` | Constraint violation |
| `ErrInvalidKey` | Key malformed or empty |
| `ErrReadOnly` | Write on read-only connection |
| `ErrTTLNotSupported` | Provider doesn't support TTL |

Check errors with `errors.Is`:

```go
user, err := store.Get(ctx, "missing")
if errors.Is(err, grub.ErrNotFound) {
    // Handle missing record
}
```

## Atomic Views

For framework internals needing field-level access:

```go
// Get atomic view (lazily cached)
atomicStore := store.Atomic()

// Access raw atom structure
atom, err := atomicStore.Get(ctx, "key")
spec := atomicStore.Spec() // Field metadata
```

**Warning:** `Atomic()` panics if T is not atomizable. Check at startup.

See [Architecture](3.architecture.md) for details on atomic views.
