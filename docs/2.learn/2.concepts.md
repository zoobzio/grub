---
title: Concepts
description: Understanding grub's core abstractions
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - concepts
  - architecture
  - fundamentals
---

# Concepts

Grub is built on three core abstractions: **Providers**, **Services**, and **Codecs**. Understanding how these fit together enables you to use grub effectively and extend it when needed.

## Provider

A Provider is the storage backend. It handles raw byte operations without knowledge of your domain types.

```go
type Provider interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, data []byte) error
    Exists(ctx context.Context, key string) (bool, error)
    Count(ctx context.Context) (int64, error)
    List(ctx context.Context, cursor string, limit int) (keys []string, nextCursor string, err error)
    Delete(ctx context.Context, key string) error
}
```

### Key Characteristics

**Scoped by construction.** Providers are configured with their scope at creation time - a Redis prefix, an S3 bucket/prefix, a MongoDB collection, etc. This scope is invisible to the Service layer.

```go
// These providers are scoped differently but present the same interface
redisProvider := redis.New(client, "users:")           // Key prefix
s3Provider := s3.New(client, "my-bucket", "users/")    // Bucket + prefix
mongoProvider := mongo.New(collection)                  // Collection
```

**Raw bytes in, raw bytes out.** Providers don't serialize or deserialize - they store exactly what they receive. Serialization is the Codec's responsibility.

**Backend-specific behavior.** Each provider maps grub operations to its backend's semantics. A Redis `Set` becomes `SET`, an S3 `Set` becomes `PutObject`, a MongoDB `Set` becomes `ReplaceOne` with upsert.

### Provider Selection

| Need | Provider | Why |
|------|----------|-----|
| Fast caching | Redis | In-memory, sub-millisecond |
| Document storage | S3, GCS, Azure | Unlimited scale, cheap |
| Flexible queries | MongoDB | Rich query language |
| Serverless | DynamoDB | Auto-scaling, pay-per-request |
| Local persistence | BoltDB, BadgerDB | No infrastructure |
| Google ecosystem | Firestore | Real-time sync, Firebase integration |

## Service

A Service wraps a Provider with type safety, serialization, and observability.

```go
type Service[T any] struct {
    provider Provider
    codec    Codec
    key      capitan.Key
    metadata sentinel.Metadata
}
```

### Generic Type Safety

Services use Go generics to provide compile-time type checking:

```go
users := grub.New[User](provider)
orders := grub.New[Order](provider)

// Type-safe operations
user, err := users.Get(ctx, "usr-123")     // Returns *User, not interface{}
order, err := orders.Get(ctx, "ord-456")   // Returns *Order
```

This eliminates runtime type assertions and catches type mismatches at compile time.

### One Provider, Many Services

A single provider can back multiple services. Each service operates on its own key space through the provider's scoping:

```go
provider := redis.New(client, "myapp:")

// These services share the provider but operate independently
users := grub.New[User](provider)       // Uses provider's prefix scope
sessions := grub.New[Session](provider) // Same provider, same scope
```

### Observability

Every Service operation emits Capitan signals:

```go
// These signals are defined in grub/signals.go
var (
    GetStarted     = capitan.NewSignal("grub.get.started", "Get operation started")
    GetCompleted   = capitan.NewSignal("grub.get.completed", "Get operation completed")
    GetFailed      = capitan.NewSignal("grub.get.failed", "Get operation failed")
    // ... similar for Set, Delete, List, Count, Exists
)
```

Hook into these for metrics, logging, or tracing:

```go
capitan.Hook(grub.GetCompleted, func(ctx context.Context, e *capitan.Event) {
    duration := grub.FieldDuration.From(e)
    key := grub.FieldKey.From(e)
    metrics.RecordLatency("grub.get", duration, "key", key)
})
```

## Codec

A Codec handles serialization between your domain types and raw bytes.

```go
type Codec interface {
    Marshal(v any) ([]byte, error)
    Unmarshal(data []byte, v any) error
    ContentType() string
}
```

### Default JSON Codec

Grub ships with a JSON codec used by default:

```go
type JSONCodec struct{}

func (c JSONCodec) Marshal(v any) ([]byte, error) {
    return json.Marshal(v)
}

func (c JSONCodec) Unmarshal(data []byte, v any) error {
    return json.Unmarshal(data, v)
}

func (c JSONCodec) ContentType() string {
    return "application/json"
}
```

### Custom Codecs

Provide your own codec for different serialization formats:

```go
// Protocol Buffers codec
type ProtoCodec struct{}

func (c ProtoCodec) Marshal(v any) ([]byte, error) {
    msg, ok := v.(proto.Message)
    if !ok {
        return nil, errors.New("value must implement proto.Message")
    }
    return proto.Marshal(msg)
}

func (c ProtoCodec) Unmarshal(data []byte, v any) error {
    msg, ok := v.(proto.Message)
    if !ok {
        return errors.New("value must implement proto.Message")
    }
    return proto.Unmarshal(data, msg)
}

func (c ProtoCodec) ContentType() string {
    return "application/protobuf"
}

// Use it
svc := grub.New[*MyProtoMessage](provider, grub.WithCodec[*MyProtoMessage](ProtoCodec{}))
```

## Lifecycle

The Lifecycle interface provides connection management for providers:

```go
type Lifecycle interface {
    Connect(ctx context.Context) error
    Close(ctx context.Context) error
    Health(ctx context.Context) error
}
```

### Connect

Establishes the connection to the backing store. Most providers are pre-configured with their client, so `Connect` is typically a no-op.

```go
// Typically handled at provider construction
provider := redis.New(client, "prefix:")

// Explicit connect (usually unnecessary)
if err := provider.Connect(ctx); err != nil {
    return err
}
```

### Close

Releases resources and closes connections. Call this during graceful shutdown:

```go
func main() {
    provider := redis.New(client, "myapp:")
    defer provider.Close(context.Background())

    // ... application logic
}
```

### Health

Performs a minimal operation to verify connectivity. Use for readiness probes:

```go
http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
    if err := provider.Health(r.Context()); err != nil {
        w.WriteHeader(http.StatusServiceUnavailable)
        return
    }
    w.WriteHeader(http.StatusOK)
})
```

Each provider implements Health differently:

| Provider | Health Check |
|----------|--------------|
| Redis | PING command |
| S3 | HeadBucket |
| MongoDB | Ping |
| DynamoDB | DescribeTable |
| Firestore | List 1 document |
| GCS | Bucket attributes |
| Azure | Container properties |
| BoltDB | Read transaction |
| BadgerDB | Read transaction |

## Error Semantics

Grub defines semantic errors for consistent error handling across providers:

```go
var (
    ErrNotFound      = errors.New("grub: record not found")
    ErrAlreadyExists = errors.New("grub: record already exists")
    ErrInvalidKey    = errors.New("grub: invalid key")
    ErrEncode        = errors.New("grub: encoding failed")
    ErrDecode        = errors.New("grub: decoding failed")
    ErrUnsupported   = errors.New("grub: operation not supported")
)
```

Providers map their backend-specific errors to these semantics:

```go
// In Redis provider
if errors.Is(err, redis.Nil) {
    return nil, grub.ErrNotFound
}

// In S3 provider
var noSuchKey *types.NoSuchKey
if errors.As(err, &noSuchKey) {
    return nil, grub.ErrNotFound
}
```

Handle errors consistently regardless of provider:

```go
user, err := users.Get(ctx, id)
if errors.Is(err, grub.ErrNotFound) {
    return nil, ErrUserNotFound
}
if err != nil {
    return nil, fmt.Errorf("failed to get user: %w", err)
}
```

## Data Flow

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│ Application │────▶│   Service   │────▶│   Codec     │────▶│  Provider   │
│   (User)    │     │  (typed)    │     │ (serialize) │     │  (bytes)    │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
                           │                                       │
                           │         Capitan Signals               │
                           └──────────────────────────────────────▶│
                                                                   ▼
                                                            ┌─────────────┐
                                                            │   Backend   │
                                                            │ (Redis/S3/…)│
                                                            └─────────────┘
```

1. Application calls `service.Set(ctx, key, user)`
2. Service serializes `user` via Codec → `[]byte`
3. Service calls `provider.Set(ctx, key, data)`
4. Provider stores bytes in backend
5. Service emits `SetCompleted` signal with duration

## Next Steps

- **[Architecture](3.architecture.md)** - Internal structure and design decisions
- **[Providers Guide](../3.guides/1.providers.md)** - Configure each backend
- **[Lifecycle Guide](../3.guides/2.lifecycle.md)** - Connection management patterns
