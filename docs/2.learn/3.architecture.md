---
title: Architecture
description: How grub is structured internally
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - architecture
  - internals
  - design
---

# Architecture

This document explains grub's internal structure and the design decisions behind it. Understanding the architecture helps you extend grub and debug issues effectively.

## Package Structure

```
grub/
├── api.go           # Provider, Codec, Lifecycle interfaces
├── service.go       # Generic Service[T] implementation
├── codec.go         # JSONCodec default implementation
├── options.go       # Service configuration options
├── signals.go       # Capitan signals for observability
├── pkg/             # Provider implementations
│   ├── redis/
│   ├── s3/
│   ├── mongo/
│   ├── dynamo/
│   ├── firestore/
│   ├── gcs/
│   ├── azure/
│   ├── bolt/
│   └── badger/
└── testing/         # Test utilities
    └── helpers.go   # MockProvider
```

### Core Package

The root `grub` package contains:

- **Interfaces** (`api.go`): Provider, Codec, Lifecycle - the contracts that providers implement
- **Service** (`service.go`): The generic typed wrapper that applications use
- **Errors**: Semantic error types for consistent error handling

### Provider Packages

Each provider is a separate Go module under `pkg/`. This design:

- **Isolates dependencies**: S3 users don't import MongoDB drivers
- **Enables independent versioning**: Provider updates don't require core updates
- **Reduces binary size**: Only imported providers are compiled in

```go
// Only pulls in Redis dependencies
import "github.com/zoobzio/grub/pkg/redis"

// Doesn't affect binary if not imported
// import "github.com/zoobzio/grub/pkg/mongo"
```

## Interface Design

### Provider Interface

The Provider interface is intentionally minimal:

```go
type Provider interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, data []byte) error
    Exists(ctx context.Context, key string) (bool, error)
    Count(ctx context.Context) (int64, error)
    List(ctx context.Context, cursor string, limit int) (keys []string, nextCursor string, err error)
    Delete(ctx context.Context, key string) error
}
```

**Design decisions:**

1. **Bytes, not types**: Providers handle `[]byte`, not domain types. Serialization belongs in the Service layer.

2. **String keys**: All backends support string keys. Complex key schemes are handled through prefixing at the provider level.

3. **Cursor-based pagination**: `List` uses opaque string cursors rather than offset/limit. This works consistently across all backends.

4. **No batch operations**: Single-record operations only. Batch operations vary too much between backends to abstract cleanly.

### Lifecycle Interface

```go
type Lifecycle interface {
    Connect(ctx context.Context) error
    Close(ctx context.Context) error
    Health(ctx context.Context) error
}
```

**Separated from Provider** because:

1. Not all contexts need lifecycle management (e.g., tests with mocks)
2. Lifecycle is orthogonal to CRUD operations
3. Allows type assertions when lifecycle is needed

```go
// Only use lifecycle when needed
if lc, ok := provider.(grub.Lifecycle); ok {
    defer lc.Close(ctx)
}
```

## Service Implementation

The Service wraps Provider with generics and observability:

```go
type Service[T any] struct {
    provider Provider
    codec    Codec
    key      capitan.Key
    metadata sentinel.Metadata
}
```

### Generic Type Flow

```go
func (s *Service[T]) Get(ctx context.Context, key string) (*T, error) {
    // 1. Call provider for raw bytes
    data, err := s.provider.Get(ctx, key)

    // 2. Create zero value of T
    var result T

    // 3. Unmarshal into result
    if err := s.codec.Unmarshal(data, &result); err != nil {
        return nil, fmt.Errorf("%w: %v", ErrDecode, err)
    }

    // 4. Return pointer to typed result
    return &result, nil
}
```

### Observability Integration

Every operation emits signals via Capitan:

```go
func (s *Service[T]) Get(ctx context.Context, key string) (*T, error) {
    start := time.Now()

    capitan.Emit(ctx, GetStarted, FieldKey.Field(key))

    data, err := s.provider.Get(ctx, key)
    if err != nil {
        capitan.Emit(ctx, GetFailed, FieldKey.Field(key), FieldError.Field(err))
        return nil, err
    }

    // ... unmarshal ...

    capitan.Emit(ctx, GetCompleted,
        FieldKey.Field(key),
        FieldDuration.Field(time.Since(start)),
    )

    return &result, nil
}
```

## Provider Implementation Patterns

All providers follow consistent patterns:

### Construction

Providers receive pre-configured clients and scope parameters:

```go
func New(client Client, prefix string) *Provider {
    return &Provider{
        client: client,
        prefix: prefix,
    }
}
```

This pattern:
- Separates client configuration from provider logic
- Enables dependency injection for testing
- Allows sharing clients across providers

### Key Prefixing

Providers that use key prefixing implement helper methods:

```go
func (p *Provider) prefixKey(key string) string {
    return p.prefix + key
}

func (p *Provider) stripPrefix(key string) string {
    if len(key) >= len(p.prefix) {
        return key[len(p.prefix):]
    }
    return key
}
```

### Error Mapping

Providers map backend errors to grub semantics:

```go
func (p *Provider) Get(ctx context.Context, key string) ([]byte, error) {
    result, err := p.client.Get(ctx, p.prefixKey(key))
    if err != nil {
        if errors.Is(err, redis.Nil) {
            return nil, grub.ErrNotFound  // Map to semantic error
        }
        return nil, err  // Pass through other errors
    }
    return result, nil
}
```

### Interface Verification

Every provider includes compile-time interface checks:

```go
var (
    _ grub.Provider  = (*Provider)(nil)
    _ grub.Lifecycle = (*Provider)(nil)
)
```

## Cursor Pagination

The `List` method uses cursor-based pagination:

```go
List(ctx context.Context, cursor string, limit int) (keys []string, nextCursor string, err error)
```

### Why Cursors?

1. **Consistent across backends**: Offset/limit doesn't work for all backends (e.g., DynamoDB)
2. **Stable iteration**: New inserts don't cause skipped/duplicate records
3. **Opaque to consumers**: Backend can use whatever internal representation works

### Cursor Implementations

| Provider | Internal Cursor | Format |
|----------|-----------------|--------|
| Redis | SCAN cursor | uint64 as string |
| S3 | Continuation token | Opaque AWS token |
| MongoDB | Last document _id | Document ID string |
| DynamoDB | LastEvaluatedKey | Partition key value |
| BoltDB | Last key | Key bytes as string |

### Usage Pattern

```go
var allKeys []string
cursor := ""

for {
    keys, nextCursor, err := provider.List(ctx, cursor, 100)
    if err != nil {
        return err
    }

    allKeys = append(allKeys, keys...)

    if nextCursor == "" {
        break  // No more pages
    }
    cursor = nextCursor
}
```

## Dependencies

### Core Dependencies

```
grub
├── github.com/zoobzio/capitan  # Observability signals
└── github.com/zoobzio/sentinel # Runtime reflection for metadata
```

### Provider Dependencies

Each provider has isolated dependencies:

```
grub/pkg/redis
└── github.com/redis/go-redis/v9

grub/pkg/s3
└── github.com/aws/aws-sdk-go-v2/service/s3

grub/pkg/mongo
└── go.mongodb.org/mongo-driver/v2
```

## Testing Architecture

### MockProvider

The testing package provides an in-memory provider:

```go
type MockProvider struct {
    data map[string][]byte
    mu   sync.RWMutex
}
```

MockProvider implements both Provider and Lifecycle interfaces, enabling full testing without external dependencies.

### Event Capture

For testing observability integration:

```go
type EventCapture struct {
    events []CapturedEvent
    mu     sync.Mutex
}

func (c *EventCapture) Handler() capitan.EventCallback {
    return func(_ context.Context, e *capitan.Event) {
        c.events = append(c.events, CapturedEvent{
            Signal: e.Signal(),
            Fields: e.Fields(),
        })
    }
}
```

## Design Principles

### 1. Minimal Interface

The Provider interface only includes operations that:
- Are universally supported across backends
- Have clear, consistent semantics
- Don't require backend-specific knowledge

### 2. Composition Over Inheritance

Grub uses composition throughout:
- Services compose Providers and Codecs
- Providers compose backend clients
- No inheritance hierarchies

### 3. Explicit Over Implicit

- Scoping is explicit in provider construction
- Errors are explicit semantic types
- Lifecycle management is explicit

### 4. Backend Agnosticism

The core package has zero backend-specific code. All backend knowledge lives in provider packages.

## See Also

- **[Concepts](2.concepts.md)** - High-level overview of Provider, Service, Codec
- **[Providers Guide](../3.guides/1.providers.md)** - Configuring specific backends
- **[API Reference](../5.reference/1.api.md)** - Complete interface documentation
